#!/usr/bin/env node
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/dd.ts
import chalk108 from "chalk";
import commandLineArgs2 from "command-line-args";

// src/shared/core/convertOptionsToArray.ts
function convertOptionsToArray(input) {
  return Object.keys(input).map((key) => {
    return { name: key, ...input[key] };
  });
}

// src/shared/core/help.ts
import chalk63 from "chalk";
import commandLineUsage from "command-line-usage";

// src/shared/ui/consoleDimensions.ts
import { exec } from "async-shelljs";
function consoleDimensions() {
  let [width, height] = exec("echo $(tput cols),$(tput lines)", {
    silent: true
  }).split(",").map((i) => Number(i));
  width = process.stdout.columns || width;
  height = process.stdout.rows || height;
  return { height, width };
}

// src/shared/ui/durationSince.ts
import { formatDistance } from "date-fns";

// src/shared/ui/highlightFilepath.ts
import chalk from "chalk";
function highlightFilepath(filePath, color = ["blue", void 0], highlight = [
  "blueBright",
  void 0
]) {
  if (!Array.isArray(color)) {
    color = [void 0, color];
  }
  if (!Array.isArray(highlight)) {
    highlight = [void 0, highlight];
  }
  const [modifier, foreground] = color;
  const [highModifier, highForeground] = highlight;
  const parts = filePath.split(/[/\\]/);
  const file = parts.pop();
  const path35 = parts.join("/").replace(/^(\S)/, "./$1");
  const fp = modifier ? chalk[modifier]`{${foreground} ${path35 + "/"}}` : `{${foreground} ${path35 + "/"}}`;
  const fileName = highModifier ? chalk[highModifier]`{${highForeground} ${file}}` : highForeground ? chalk[highForeground]`${file}}` : `${file}}`;
  return `${fp}${fileName}`;
}

// src/shared/ui/inverted.ts
import chalk2 from "chalk";
var inverted = chalk2.black.bgHex("A9A9A9");

// src/shared/ui/styles.ts
import chalk3 from "chalk";
function formatNumber(num, decimalPlaces = 0) {
  const multiplier = Math.pow(10, decimalPlaces);
  const rounded = Math.round(num * multiplier) / multiplier;
  return rounded.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
}
function green(...thingy) {
  const stringThingy = thingy.map((i) => typeof i === "number" ? formatNumber(i) : i).join("");
  return chalk3.bold.green(stringThingy);
}

// src/shared/ui/toTable.ts
import chalk4 from "chalk";
import { table } from "table";

// src/errors/DevopsError.ts
import { isTypeSubtype } from "common-types";
var DevopsError = class extends Error {
  constructor(message, classification = "do-devops/unknown") {
    super(message);
    this.kind = "DevopsError";
    const parts = classification.split("/");
    const [type, subType] = parts.length === 1 ? ["devops", parts[0]] : parts;
    this.name = `${type}/${subType}`;
    this.code = subType;
    this.classification = isTypeSubtype(classification) ? classification : `do-devops/${classification.replace(/\//g, "")}`;
  }
};

// src/shared/ui/toTable.ts
function isAdvancedColumn(col) {
  return col !== null && typeof col === "object";
}
function isColumnTuple(col) {
  return Array.isArray(col);
}
function headerCol(name) {
  return chalk4.bold.blue(name);
}
function toTable(data, ...columns) {
  const ui = consoleDimensions();
  const hiddenColumns = [];
  const headerRow = [];
  const colConfig = [];
  for (const col of columns) {
    if (isAdvancedColumn(col)) {
      if (col.minWidth === void 0 || col.minWidth < ui.width) {
        headerRow.push(headerCol(col.name || col.col));
        if (col.format) {
          colConfig.push(col.format);
        }
      } else {
        hiddenColumns.push(col.name || col.col);
      }
    } else {
      headerRow.push(headerCol(Array.isArray(col) ? col[0] : col));
      colConfig.push({});
    }
  }
  const rows = data.map((rowData) => {
    const row = [];
    for (const col of columns) {
      if (isColumnTuple(col)) {
        const [prop, fn] = col;
        row.push(fn(rowData[prop]));
      } else if (isAdvancedColumn(col)) {
        if (col.minWidth === void 0 || col.minWidth < ui.width) {
          row.push(col.formula ? col.formula(rowData[col.col]) : rowData[col.col]);
        }
      } else {
        row.push(rowData[col]);
      }
    }
    return row;
  });
  const hiddenColMessage = hiddenColumns.length > 0 ? chalk4.gray`\n\n - {bold Note:} some columns hidden due to available width [ ${chalk4.dim(ui.width)} ]: ${chalk4.italic(hiddenColumns.join(", "))}` : "";
  const tableData = [headerRow, ...rows];
  try {
    return table(tableData, { columns: colConfig }) + hiddenColMessage;
  } catch (error) {
    const errMessage = error.message === "Table must have a consistent number of cells." ? `     - table row lengths are: 
${tableData.map((i) => i.length)}` : `- ${"\u{1F4A9}" /* poop */} problems building table: ${error.message}`;
    throw new DevopsError(errMessage, "ui/invalid-table-data");
  }
}

// src/shared/ui/wordWrap.ts
import smartwrap from "smartwrap";
function wordWrap(text, options15 = {}) {
  text = options15.removeExistingCR ? text.replace(/\n/g, "") : text;
  const { width: w2 } = consoleDimensions();
  return smartwrap(text, { width: options15.wrapDistance || Math.min(80, w2) });
}

// src/shared/core/util/argv.ts
function hasArgv(cmd) {
  return !Object.keys(cmd?.options || {}).every(
    (k) => !(cmd?.options)[k]?.defaultOption
  );
}
function getArgvOption(cmd) {
  const o = cmd?.options || {};
  return Object.keys(o).reduce((acc, key) => {
    if (o[key].defaultOption) {
      return { ...o[key], name: key };
    }
    return acc;
  }, void 0);
}

// src/shared/core/util/commandAnnouncement.ts
import chalk60 from "chalk";

// src/shared/core/logger.ts
var options;
function logger(opts) {
  if (opts) {
    options = opts;
  } else if (!opts && !options) {
    console.warn(
      `Trying to use logger without having first set global options. Outside of testing, this should be avoided by ensuring all CLI commands set the options up front.`
    );
    options = { verbose: true, quiet: false };
  }
  return {
    info(...args) {
      if (!options.quiet) {
        console.error(...args);
      }
    },
    shout(...args) {
      console.error(...args);
    },
    dryRun(...args) {
      if (options.dryRun) {
        args[0] = `- [DRY RUN] ${args[0]}`;
        console.log(...args);
      }
    },
    whisper(...args) {
      if (options.verbose) {
        console.error(...args);
      }
    }
  };
}

// src/shared/core/util/doDevopsVersion.ts
import chalk59 from "chalk";

// src/shared/file/base-paths/libraryDirectory.ts
import { join } from "pathe";

// src/shared/file/relativePath.ts
function toRelativePath(path35, base) {
  return path35.replace(base || process.cwd(), "").replace(/^\//, "");
}

// src/shared/file/base-paths/libraryDirectory.ts
import { fileURLToPath } from "url";
function libraryDirectory(offset, opts = {}) {
  const base = fileURLToPath(new URL(".", import.meta.url)).replace("bin/", "");
  const dir = offset ? join(base, offset) : base;
  return opts.base ? toRelativePath(dir, opts.base) : dir;
}

// src/shared/file/existence/fileExists.ts
import { existsSync } from "fs";

// src/shared/file/helpers/interpolateFilepath.ts
import { homedir } from "os";
import { join as join2 } from "pathe";
function interpolateFilePath(filename) {
  if (filename.slice(0, 2) === "src/") {
    filename = join2(homedir(), filename.slice(1));
  }
  if (filename.slice(0, 2) === "./") {
    filename = join2(process.cwd(), filename.slice(2));
  }
  return filename;
}

// src/shared/file/existence/fileExists.ts
function fileExists(file) {
  try {
    const f = interpolateFilePath(file);
    return existsSync(f);
  } catch {
    return false;
  }
}

// src/shared/npm/timingFromNpmInfo.ts
import { first, last } from "native-dash";

// src/shared/npm/crud/installDevDep.ts
import chalk56 from "chalk";
import { execSync } from "child_process";

// src/shared/observations/determineAccountId.ts
import { isAwsAccountId } from "common-types";

// src/shared/aws/addAwsProfile.ts
import { join as join3 } from "pathe";

// src/shared/aws/askForAwsProfile.ts
import inquirer3 from "inquirer";

// src/shared/interactive/askForDataFile.ts
import inquirer from "inquirer";

// src/shared/file/getDataFiles.ts
import { globby } from "globby";
import path from "path";
import process2 from "process";
function strip(opts) {
  return (results) => {
    if (opts.filterBy) {
      results = results.filter((i) => i.includes(opts.filterBy));
    }
    if (opts.stripFileExtension) {
      results = results.map((i) => i.replace(/(.*)\.\w*$/, "$1"));
    }
    const prefix = process2.cwd() + "/test/data/";
    return results.map((i) => i.replace(prefix, ""));
  };
}
async function getDataFiles(opts = {}) {
  const glob = path.join(
    process2.cwd(),
    "test/data",
    opts.fileType ? `**/*.${opts.fileType}` : "**/*"
  );
  const results = await globby(glob);
  return strip(opts)(results);
}

// src/shared/file/getMonoRepoPackages.ts
import { globby as globby2 } from "globby";
import { dirname } from "pathe";
async function getMonoRepoPackages(baseDir, exclude = []) {
  const glob = ["**/package.json", "!**/node_modules"];
  return (await globby2(glob, { cwd: baseDir, deep: 10 })).map((i) => {
    return {
      name: getPackageJson(i).name || "unknown",
      path: dirname(i)
    };
  }).filter((i) => i.path !== ".").filter((i) => !exclude.includes(i.name));
}

// src/shared/file/readDataFile.ts
import path2 from "path";
import * as process3 from "process";
async function readDataFile(file, defaultExtension) {
  if (defaultExtension && defaultExtension.slice(0, 1) === ".") {
    defaultExtension = defaultExtension.slice(1);
  }
  let filename = path2.join(process3.cwd(), "test/data", file);
  if (defaultExtension && !file.includes("." + defaultExtension)) {
    filename += "." + defaultExtension;
  }
  return readFile(filename);
}

// src/shared/file/saveFileToHomeDirectory.ts
import { join as join4 } from "pathe";

// src/shared/file/saveYamlFile.ts
import chalk5 from "chalk";
import path3 from "path";
import { promisify } from "util";
import { dump } from "js-yaml";
import { writeFile } from "fs";
import { exit } from "process";
var write = promisify(writeFile);
var saveYamlFile = async (filename, data) => {
  try {
    console.log(data);
    const yamlData = dump(data);
    const fqFilename = path3.join(process.cwd(), filename);
    await write(fqFilename, yamlData, { encoding: "utf8" });
    return;
  } catch (error) {
    console.log(
      `- {red writing the ${chalk5.bold.italic(filename)} YAML file has failed!} ${"\u{1F4A9}" /* poop */}}`
    );
    console.log(error.message);
    console.log(chalk5.dim`${error.stack}`);
    exit(1);
  }
};

// src/shared/file/base-paths/currentDirectory.ts
import path4 from "path";
function currentDirectory(offset, opts = {}) {
  const base = offset ? path4.posix.join(process.cwd(), offset) : process.cwd();
  return opts.base ? toRelativePath(base, opts.base) : base;
}

// src/shared/stack/getCaller.ts
import callsites from "callsites";

// src/shared/file/base-paths/homeDirectory.ts
import path5 from "path";
import { homedir as homedir2 } from "os";
function homeDirectory(offset, opts = {}) {
  const home = offset ? path5.posix.join(homedir2(), offset) : homedir2();
  return opts.base ? toRelativePath(home, opts.base) : home;
}

// src/shared/file/base-paths/parentDirectory.ts
import path6 from "path";
function parentDirectory(offset, opts = {}) {
  const cwd6 = path6.posix.join(process.cwd(), "../");
  const base = offset ? path6.posix.join(cwd6, offset) : cwd6;
  return opts.base ? toRelativePath(base, opts.base) : base;
}

// src/shared/file/base-paths/repoDirectory.ts
import chalk6 from "chalk";
import path7, { join as join5 } from "path";
function repoDirectory(offset, opts = {}) {
  const start = offset ? path7.posix.join(process.cwd(), offset) : process.cwd();
  if (fileExists(currentDirectory("package.json"))) {
    return currentDirectory(offset);
  }
  const dir = findPackageJson(parentDirectory());
  if (!dir) {
    throw new DevopsError(
      `Attempt to locate the root of the repo for the current directory failed. No "package.json" was found above the ${chalk6.blue(start)} directory`,
      "directory/not-found"
    );
  }
  const filename = join5(dir, offset ?? "");
  return opts.base ? toRelativePath(filename, opts.base) : filename;
}

// src/shared/file/crud/readFile.ts
import chalk7 from "chalk";
import { readFileSync } from "fs";

// src/shared/file/existence/filesExist.ts
import { existsSync as existsSync2 } from "fs";
import { homedir as homedir3 } from "os";
import path8 from "path";
function filesExist(...files) {
  const exists3 = [];
  for (let f of files) {
    if (![".", "/", "~"].includes(f.slice(0, 1))) {
      f = path8.posix.join(process.cwd(), f);
    }
    if (f.slice(0, 1) === "~") {
      f = path8.posix.join(homedir3(), f.slice(1));
    }
    if (existsSync2(f)) {
      exists3.push(f);
    }
  }
  return exists3.length > 0 ? exists3 : false;
}

// src/shared/file/crud/readFile.ts
function readFile(filename) {
  filename = interpolateFilePath(filename);
  try {
    return filesExist(filename) ? readFileSync(filename, { encoding: "utf8" }) : void 0;
  } catch (error) {
    console.log(
      `{red - ${"\u{1F4A9}" /* poop */} ran into a problem reading file ${chalk7.blue`${filename}.`} Error message: ${error.message}`
    );
    console.log(`- Stack:
${chalk7.dim(error.stack)}`);
    process.exit(1);
  }
}

// src/shared/file/crud/readAndParseFile.ts
import parse from "destr";

// src/shared/file/crud/readYamlConfig.ts
import { load } from "js-yaml";
import chalk8 from "chalk";

// src/shared/file/crud/removeFile.ts
import { lstatSync, rmSync } from "fs";
function removeFile(filename) {
  filename = interpolateFilePath(filename);
  if (!fileExists(filename)) {
    throw new DevopsError(
      `Attempt to remove a file -- ${filename} -- which does not exist!`,
      "removal-failed/does-not-exist"
    );
  }
  const stat2 = lstatSync(filename);
  if (!stat2.isFile()) {
    throw new DevopsError(
      `Can not remove the file "${filename}" as it is not a file!`,
      "removal-failed/not-file"
    );
  }
  try {
    rmSync(filename);
  } catch (error) {
    throw new DevopsError(
      `Problem encountered trying to remove file "${filename}": ${error.message}`,
      "removal-failed/other"
    );
  }
}

// src/shared/file/crud/write.ts
import { mkdirSync, writeFileSync } from "fs";

// src/shared/file/existence/commandIsAvailable.ts
import { spawnSync } from "child_process";
function commandIsAvailable(cmd) {
  const thread = spawnSync("which", [cmd], { stdio: "inherit", timeout: 0 });
  if (thread.error) {
    return false;
  }
  ;
  return true;
}

// src/shared/file/existence/dirExists.ts
import { existsSync as existsSync3, lstatSync as lstatSync2 } from "fs";
function dirExists(dir, ignoreSymLink = false) {
  dir = interpolateFilePath(dir);
  const exists3 = existsSync3(dir);
  if (!exists3) {
    return false;
  }
  const info2 = lstatSync2(dir);
  const isSymLink = info2.isSymbolicLink();
  const isDirectory = info2.isDirectory();
  if (!isDirectory) {
    throw new DevopsError(
      `The test to see if the path "${dir}" as a directory failed because that path exists but it is NOT a directory!`,
      "dir/exists-not-dir"
    );
  }
  return !isSymLink || ignoreSymLink;
}

// src/shared/file/existence/ensureDirectory.ts
import * as fs from "fs";
import { promisify as promisify2 } from "util";
var exists2 = promisify2(fs.exists);
var mkdir2 = promisify2(fs.mkdir);
async function ensureDirectory(dir) {
  const doesExist = await exists2(dir);
  if (!doesExist) {
    await mkdir2(dir, { recursive: true });
    return true;
  }
  return;
}

// src/shared/file/crud/write.ts
import path9 from "path";

// src/@type-guards/errors.ts
function isDevopsError(err) {
  return typeof err === "object" && err.kind === "DevopsError";
}
function isClassification(error, classification) {
  return isDevopsError(error) && error.classification === classification;
}

// src/@type-guards/image-guards.ts
function isExifDate(d) {
  return typeof d === "object" && Object.keys(d).includes("year") && !Object.keys(d).includes("second") && Object.keys(d).includes("zone");
}

// src/shared/file/crud/write.ts
import chalk9 from "chalk";
function write2(filename, data, options15 = {}) {
  try {
    const content = typeof data === "string" ? data : options15.pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
    filename = interpolateFilePath(filename);
    let offset;
    while (options15.offsetIfExists && fileExists(filename)) {
      const before = new RegExp(`-${offset}.(.*)$`);
      filename = offset ? filename.replace(before, ".$1") : filename;
      offset = offset ? offset++ : 1;
      const parts = filename.split(".");
      filename = parts.slice(0, -1).join(".") + `-${offset}.` + parts.slice(-1);
    }
    if (!options15.offsetIfExists && !options15.allowOverwrite && fileExists(filename)) {
      throw new DevopsError(
        `The file "${filename}" already exists and the ${chalk9.italic`overwrite`} flag was not set. Write was not allowed.`,
        "do-devops/file-exists"
      );
    }
    if (!dirExists(path9.dirname(filename))) {
      mkdirSync(path9.dirname(filename), { recursive: true });
    }
    writeFileSync(filename, content, {
      encoding: "utf8"
    });
    return { filename, data };
  } catch (error) {
    if (isClassification(error, "do-devops/file-exists")) {
      throw error;
    }
    throw new DevopsError(
      `Problem writing file "${filename}": ${error.message}`,
      "do-devops/file-write-error"
    );
  }
}

// src/shared/file/utility/diffFiles.ts
import chalk10 from "chalk";
import { diffChars } from "diff";
function diffFiles(file1, file2) {
  const content1 = readFile(file1);
  const content2 = readFile(file2);
  if (content1 && content2) {
    const differences = diffChars(content1, content2);
    for (const block of differences) {
      const color = block.added ? chalk10.green : block.removed ? chalk10.red : chalk10.gray;
      process.stdout.write(color(block.value));
    }
  }
  console.log();
}

// src/shared/file/utility/directoryFiles.ts
import { readdirSync, lstatSync as lstatSync3 } from "fs";
import path10 from "path";
function directoryFiles(dir) {
  try {
    const files = readdirSync(dir);
    return files.reduce((agg, file) => {
      const stats = lstatSync3(path10.posix.join(dir, file));
      agg.push({ file, stats });
      return agg;
    }, []);
  } catch (error) {
    throw new DevopsError(
      `Attempt to get files from the directory "${dir}" failed: ${error.message}`,
      "do-devops/directoryFiles"
    );
  }
}

// src/shared/file/utility/fileInfo.ts
import { stat } from "fs";
import path11 from "path";
import { promisify as promisify3 } from "util";
var info = promisify3(stat);
async function fileInfo(...files) {
  let rememberFile;
  try {
    const promises = [];
    for (const file of files.filter(Boolean)) {
      const parts = getFileComponents(file);
      promises.push(
        info(file).then((s) => {
          return { ...parts, ...s };
        })
      );
    }
    const results = await Promise.all(promises);
    return results;
  } catch (error) {
    throw new DevopsError(
      `Attempt to get info/stat from the file "${rememberFile}" [ ${path11.join(
        process.cwd(),
        rememberFile || ""
      )} ] failed [ call included request for ${files.length} files ]: ${error.message}`,
      "do-devops/filesInfo"
    );
  }
}

// src/shared/file/utility/getAllFilesOfType.ts
import { globbySync as sync } from "globby";
import { join as join6 } from "pathe";

// src/shared/file/utility/getFileComponents.ts
function getFileComponents(filepath, base) {
  const relative3 = toRelativePath(filepath, base);
  const parts = relative3.split("/");
  const start = parts.length > 1 ? parts[0] : "";
  const mid = parts.length > 2 ? parts.slice(1, -1).join("/") : "";
  const filename = parts.slice(-1)[0];
  const match = filename.trim().match(/\.(\w*)$/);
  const ext = match[1];
  const re = new RegExp(`.${ext}`);
  const fileWithoutExt = filename.replace(re, "");
  return {
    start,
    mid,
    filename,
    fileWithoutExt,
    ext,
    filepath: [start, mid].join("/"),
    full: filepath
  };
}

// src/shared/file/utility/getFilesUnderPath.ts
import { globby as globby3 } from "globby";
async function getFilesUnderPath(dir, extension) {
  dir = dir.replace(/\\/g, "/");
  const pattern = extension ? `${dir}/**/*.${extension}` : `${dir}/**`;
  const files = await globby3(pattern);
  return files || [];
}

// src/shared/file/utility/getSubdirectories.ts
import path12 from "path";
import { readdirSync as readdirSync2, lstatSync as lstatSync4 } from "fs";
function getSubdirectories(dir) {
  try {
    const files = readdirSync2(dir);
    return files.filter((f) => {
      const stats = lstatSync4(path12.posix.join(dir, f));
      return stats.isDirectory();
    });
  } catch (error) {
    throw new DevopsError(
      `Attempt to get files from the directory "${dir}" failed: ${error.message}`,
      "do-devops/directoryFiles"
    );
  }
}

// src/shared/file/utility/isValidServerlessTs.ts
import chalk11 from "chalk";

// src/shared/file/utility/symlinks.ts
import { readlinkSync } from "fs";
import path13 from "path";
function symlinks(dir, filter3) {
  return directoryFiles(dir).filter((f) => {
    if (!f.stats.isSymbolicLink()) {
      return false;
    }
    if (!filter3) {
      return true;
    }
    return filter3 === "only-dirs" ? f.stats.isDirectory() : !f.stats.isDirectory();
  }).map((lnk) => {
    const fullPath = path13.posix.join(dir, lnk.file);
    const linkTo = readlinkSync(fullPath, { encoding: "utf8" });
    return { ...lnk, linkTo };
  });
}

// src/shared/file/utility/templateDirCopy.ts
import path14 from "path";
async function templateDirCopy(source, target, replacements) {
  source = path14.posix.join(libraryDirectory("/templates"), source);
  target = path14.posix.join(currentDirectory(), target);
  if (!dirExists(source)) {
    throw new DevopsError(
      `The template directory "${source}" was not found!`,
      "template/source-dir-missing"
    );
  }
  const files = await getFilesUnderPath(source);
  const problems = [];
  const transferred = [];
  for (const sourceFile of files) {
    const targetFile = path14.posix.join(target, getFileComponents(sourceFile).filename);
    const completed = await templateFileCopy(
      sourceFile.replace(libraryDirectory("templates"), ""),
      targetFile.replace(currentDirectory(), ""),
      replacements
    );
    if (!completed) {
      problems.push(sourceFile);
    } else {
      transferred.push(sourceFile);
    }
  }
  return { transferred, ...problems.length > 0 ? { problems } : {} };
}

// src/shared/file/utility/templateFileCopy.ts
import path15 from "path";
async function templateFileCopy(source, target, replacements) {
  source = path15.posix.join(libraryDirectory("/templates"), source);
  target = path15.posix.join(currentDirectory(), target);
  let content = readFile(source);
  if (content === void 0) {
    throw new DevopsError(
      `The template file "${source}" was not found!`,
      "template/source-file-missing"
    );
  }
  if (replacements) {
    for (const lookFor of Object.keys(replacements)) {
      const re = new RegExp(lookFor, "g");
      content = content.replace(re, replacements[lookFor]);
    }
  }
  if (fileExists(target)) {
    const copy = await askAboutFileOverwrite(source, target);
    if (copy) {
      write2(target, content, { allowOverwrite: true });
    } else {
      return false;
    }
  } else {
    write2(target, content);
  }
  return true;
}

// src/shared/file/utility/tscValidation.ts
import chalk12 from "chalk";

// src/shared/interactive/askForDataFile.ts
async function askForDataFile(listOfFiles) {
  const files = listOfFiles ? listOfFiles : await getDataFiles();
  const question = {
    type: "list",
    name: "file",
    message: "What data file would you like?",
    default: files[0],
    choices: files
  };
  const answer = await inquirer.prompt(question);
  return answer.file;
}

// src/shared/interactive/general/ask.ts
import inquirer2 from "inquirer";
async function ask(question) {
  return inquirer2.prompt([question]);
}

// src/shared/interactive/general/convertChoices.ts
function convertChoices(choices) {
  return Array.isArray(choices) ? choices.map((c) => ({
    type: "choice",
    name: String(c),
    value: c
  })) : Object.keys(choices).reduce((acc, key) => {
    return [
      ...acc,
      {
        type: "choice",
        name: String(choices[key]),
        value: key
      }
    ];
  }, []);
}

// src/shared/interactive/general/askCheckboxQuestion.ts
async function askCheckboxQuestion(question, choices, options15 = {}) {
  const defaultValues = {
    when: options15.when || (() => true),
    default: options15.default || convertChoices(choices)[0].value
  };
  const q = {
    type: "checkbox",
    name: "checkedValues",
    message: question,
    choices,
    ...defaultValues
  };
  const answer = await ask(q);
  return answer.checkedValues;
}

// src/shared/interactive/general/confirmQuestion.ts
var confirmQuestion = (name, question, options15 = { choices: { true: "Y", false: "N" } }) => {
  const defaultValues = {
    when: options15.when || (() => true),
    default: options15.default || true
  };
  return {
    name,
    type: "confirm",
    message: question,
    ...defaultValues
  };
};

// src/shared/interactive/general/askConfirmQuestion.ts
var askConfirmQuestion = async (question, options15 = { choices: { true: "Y", false: "N" } }) => {
  const q = confirmQuestion("confirmQuestion", question, options15);
  const answer = await ask(q);
  return answer.yesOrNo;
};

// src/shared/interactive/general/askForNestedDirectory.ts
import chalk13 from "chalk";
import { join as join7, relative } from "path";
async function askForNestedDirectory(ask2, options15 = {}) {
  let operatingDir = options15.startDir ? options15.startDir : repoDirectory();
  const dirs = [];
  let choice = "";
  const filter3 = options15.filter || (() => true);
  const COMPLETED = "COMPLETED";
  while (choice !== COMPLETED) {
    const subDirs = dirs.length === 0 && options15.initialChoices ? options15.initialChoices : dirs.length === 0 && options15.leadChoices ? [.../* @__PURE__ */ new Set([...options15.leadChoices, ...getSubdirectories(operatingDir).filter(filter3)])] : getSubdirectories(operatingDir).filter(filter3);
    if (subDirs.length === 0) {
      choice === COMPLETED;
      break;
    } else {
      choice = dirs.length === 0 ? await askListQuestion(ask2, [...subDirs, COMPLETED]) : await askListQuestion(
        `Thanks. The selected path so far is: ${chalk13.blue(dirs.join("/"))}
Now choose either a subdirectory or "COMPLETED" to finish the selection.`,
        [COMPLETED, ...subDirs]
      );
      if (choice !== COMPLETED) {
        dirs.push(choice);
        operatingDir = join7(operatingDir, `${choice}/`);
        const created = await ensureDirectory(operatingDir);
        if (created) {
          console.log(
            chalk13.dim`- the {bold ${choice}} directory ${chalk13.italic`didn't exist`} so we've created it for you.`
          );
          choice = COMPLETED;
        }
      }
    }
  }
  const relativeDirectory = relative(repoDirectory(), operatingDir);
  console.log(`{bold {yellow ${options15.name || "Selected Directory"}:} ${relativeDirectory}}`);
  return relativeDirectory;
}

// src/shared/interactive/general/askInputQuestion.ts
async function askInputQuestion(question, options15 = {}) {
  const q = {
    type: "input",
    name: "inputValue",
    message: question,
    default: options15.default,
    ...options15.when ? { when: options15.when } : { when: () => true }
  };
  const answer = await ask(q);
  if (answer.inputValue === "" && options15.acceptEmptyResponse === false) {
    console.log("This question requires a non-empty response!");
    return askInputQuestion(question, options15);
  }
  return answer.inputValue;
}

// src/shared/interactive/general/askListQuestion.ts
async function askListQuestion(question, choices, options15 = {}) {
  const defaultValues = {
    when: options15.when || (() => true),
    default: options15.default || convertChoices(choices)[0].value
  };
  const q = {
    type: "list",
    name: "listValue",
    message: question,
    choices: convertChoices(choices),
    ...defaultValues
  };
  const answer = await ask(q);
  return answer.listValue;
}

// src/shared/interactive/general/checkboxQuestion.ts
function checkboxQuestion(q) {
  return {
    ...q,
    type: "checkbox"
  };
}

// src/shared/interactive/specific/askAboutFileOverride.ts
import chalk14 from "chalk";
import { spawnSync as spawnSync2 } from "child_process";

// src/shared/config/getIntegratedConfig.ts
import merge from "deepmerge";
import { omit } from "native-dash";
function getIntegratedConfig() {
  const userConfig = getUserConfig();
  const projectConfig = getProjectConfig();
  if (!userConfig.userConfig && !projectConfig.projectConfig) {
    return { kind: "integrated", ready: false, userConfig: false, projectConfig: false };
  }
  const u = omit(userConfig, "kind");
  const p = omit(projectConfig, "kind");
  const merged = merge(merge(u, p), {
    kind: "integrated",
    ready: userConfig.userConfig || projectConfig.projectConfig
  });
  return merged;
}

// src/shared/config/getProjectConfig.ts
import parse2 from "destr";
import path16 from "path";

// src/shared/config/constants.ts
var CONFIG_FILE = ".do-devops.json";
var DEFAULT_PROJECT_CONFIG = {
  kind: "project",
  projectConfig: true,
  general: {},
  aws: {}
};

// src/shared/config/getProjectConfig.ts
function getProjectConfig(offset) {
  const filename = path16.join(currentDirectory(), offset || ".", CONFIG_FILE);
  return parse2(readFile(filename)) || {
    projectConfig: false,
    kind: "project"
  };
}

// src/shared/config/getUserConfig.ts
import parse3 from "destr";
function getUserConfig() {
  return parse3(readFile(homeDirectory(CONFIG_FILE))) || {
    userConfig: false,
    kind: "user"
  };
}

// src/shared/config/saveProjectConfig.ts
import merge2 from "deepmerge";
import { writeFileSync as writeFileSync2 } from "fs";
import { set } from "native-dash";
function configMerge(current, updated) {
  return {
    ...merge2(current, updated),
    kind: "project",
    projectConfig: true
  };
}
function configSet(current, dotPath, payload) {
  const config = {
    ...current,
    kind: "project",
    projectConfig: true
  };
  set(current, dotPath, payload);
  return config;
}
async function saveProjectConfig(first2, second) {
  const log = logger();
  let current = getProjectConfig();
  if (!current.projectConfig) {
    current = DEFAULT_PROJECT_CONFIG;
  }
  const newConfig = typeof first2 === "string" ? configSet(current, first2, second) : configMerge(current, first2);
  log.whisper(newConfig);
  writeFileSync2(currentDirectory(CONFIG_FILE), JSON.stringify(newConfig, null, 2), {
    encoding: "utf-8"
  });
  return newConfig;
}

// src/shared/config/saveUserConfig.ts
import merge3 from "deepmerge";
import { writeFileSync as writeFileSync3 } from "fs";
async function saveUserConfig(updated) {
  let current = getUserConfig();
  if (!current.userConfig) {
    current = { kind: "user", userConfig: true, general: {}, aws: {} };
  }
  const newConfig = { ...merge3(current, updated), kind: "user", userConfig: true };
  writeFileSync3(homeDirectory(CONFIG_FILE), JSON.stringify(newConfig, null, 2), {
    encoding: "utf8"
  });
}

// src/shared/interactive/specific/askAboutFileOverride.ts
var answers = {
  skip: "SKIP this file being from being copied",
  copy: "COPY the template file over repo's version",
  show: "SHOW both files in editor",
  diff: "Show DIFFERENCES between files in editor"
};
async function askAboutFileOverwrite(source, target, opts = /* @__PURE__ */ new Set()) {
  const parts = getFileComponents(source, libraryDirectory("templates"));
  const filename = chalk14.dim`${parts.filepath}}{bold /${parts.filename}`;
  const log = logger(opts);
  log.shout(`The file ${chalk14.blue(filename)} already exists.
`);
  let action;
  while (action !== "copy" && action !== "skip") {
    action = await askListQuestion("What do you want to do?", answers);
    if (action === "show") {
      let editorCommand = getUserConfig().general?.editorCommand;
      if (!editorCommand) {
        editorCommand = await askUserAboutEditorCommand();
        if (editorCommand) {
          log.info(
            `- the editor command "${editorCommand}" has been saved to your user configuration.`
          );
          log.info(chalk14.gray` - the user config file is located at ${chalk14.blue`src/.do-devops.json}`}`);
        }
      }
      if (editorCommand) {
        try {
          spawnSync2(editorCommand, [source, target, "&"], { stdio: "inherit" });
          log.info(`- check your editor for the two versions of the file`);
        } catch {
          log.info(`- ${"\u{1F4A9}" /* poop */} there was a problem opening the files in your editor`);
        }
      }
    }
    if (action === "diff") {
      diffFiles(source, target);
    }
  }
  return action === "copy" ? true : false;
}

// src/shared/interactive/specific/askForDependency.ts
import chalk15 from "chalk";
var LOOKUP = (p) => [
  p.hasDependencies ? { value: "dependencies", name: `Dependencies [${p.dependencies.length}]` } : false,
  p.hasPeerDependencies ? {
    value: "peerDependencies",
    name: `Peer Dependencies [${p.peerDependencies.length}]`
  } : false,
  p.hasOptionalDependencies ? {
    value: "optionalDependencies",
    name: `Optional Dependencies [${p.optionalDependencies.length}]`
  } : false,
  p.hasDevDependencies ? {
    value: "devDependencies",
    name: `Development Dependencies [${p.devDependencies.length}]`
  } : false,
  { value: false, name: "QUIT" }
].filter(Boolean);
async function askForDependency(_observations) {
  const deps = dependencies();
  const choices = LOOKUP(deps).reduce(
    (acc, curr) => ({ ...acc, [curr.value]: curr.name }),
    {}
  );
  if (Object.keys(choices).length === 1) {
    console.log(`- this repo has no dependencies!`);
    return false;
  }
  const kind = await askListQuestion(
    `Which ${chalk15.italic`type`} of dependency`,
    choices
  );
  if (!kind) {
    return false;
  }
  const depChoices = deps[kind];
  const answer = await askListQuestion(
    `- Choose the ${chalk15.italic`specific`} dependency to run "ls" on`,
    Object.fromEntries(depChoices.map((i) => [i.name, `${i.name} ${chalk15.dim`- ${i.version}`}`]))
  );
  return answer;
}

// src/shared/interactive/specific/askForUnitTestFramework.ts
import chalk16 from "chalk";
import { equal } from "native-dash";

// src/constants.ts
var IMAGE_CACHE = ".image-metadata.json";

// src/shared/interactive/specific/askUserAboutEditorCommand.ts
async function askUserAboutEditorCommand() {
  let editor = await askListQuestion("What editor command should we use to open files?", {
    code: "vs-code (using 'code' to open)",
    vim: "vim",
    subl: "Sublime Text (using 'subl' to open)",
    other: "other"
  });
  if (editor === "other") {
    editor = await askInputQuestion("what is the command for this editor?");
  }
  if (editor) {
    saveUserConfig({ general: { editorCommand: editor } });
  }
  return editor;
}

// src/shared/interactive/specific/resolvePackageManagerConflict.ts
import chalk17 from "chalk";
async function resolvePackageManagerConflict(observations) {
  const pkgManager = await askListQuestion(
    "Which package manager do you expect to use in this repo?",
    ["npm", "pnpm", "yarn"],
    {
      default: observations.has("pnpm") ? "pnpm" : observations.has("yarn") ? "yarn" : "npm"
    }
  );
  await saveProjectConfig({ general: { pkgManager } });
  const removed = await removeOtherLockFiles(pkgManager);
  if (removed.length > 0) {
    console.log(
      `- removed ${removed.length} redundant lock file${removed.length > 1 ? "s" : ""}: ${chalk17.italic.dim(removed.join(", "))}}`
    );
  }
}

// src/shared/interactive/specific/configuration/askForAutoindexConfig.ts
import chalk18 from "chalk";
import { exit as exit2 } from "process";
async function askForAutoindexConfig(opts, o) {
  const log = logger(opts);
  const projectConfig = getProjectConfig();
  const hasProjectConfig = projectConfig.autoindex !== void 0;
  if (o.has("monorepo")) {
    log.info(
      `- ${"\u{1F440}" /* eyeballs */} this project is a monorepo; you should configure 'packages' in your monorepo separately.`
    );
    const continueOn = await askConfirmQuestion(
      `You can still configure the root of the monorepo if there are index files, ${chalk18.italic`not`} in the individual packages. Otherwise there is no point. Shall we continue?`
    );
    if (!continueOn) {
      exit2(0);
    }
  }
  log.info(
    `- configuring this project for ${chalk18.bold.yellow`do-devops`}'s ${chalk18.blue`autoindex`} command
`
  );
  if (hasProjectConfig) {
    log.info(`- ${"\u{1F440}" /* eyeballs */} has existing project configuration to work from`);
  }
  let indexGlobs = ["**/index.ts", "**/index.js", "**/index.mjs", "!**/*.d.ts", "!**/node_modules"];
  const confirmIndexGlob = await askConfirmQuestion(
    `By default, the files which are identified as possible "autoindex" files are: ${chalk18.dim(JSON.stringify(indexGlobs))}. This is typically fine, shall we proceed with this or do you want to modify this?`
  );
  if (!confirmIndexGlob) {
    console.log(`- input patterns in a CSV format that can be parsed.`);
    console.log(`  for example ${chalk18.dim`[ "**foobar.ts" ] `}.`);
    console.log(
      `- Note: you should NOT include the exclusion pattern for ${chalk18.blue`node_modules`} as this will always be included`
    );
    indexGlobs = [
      ...JSON.parse(await askInputQuestion(`pattern:`)),
      "!**/node_modules"
    ];
  }
  let whitelistGlobs = projectConfig?.autoindex?.whitelistGlobs || void 0;
  let blacklistGlobs = projectConfig?.autoindex?.blacklistGlobs || [];
  const confirmWhitelist = whitelistGlobs === void 0 ? await askConfirmQuestion(
    `- you ${chalk18.italic("can")} specify a particular whitelist -- or set of whitelists -- to identify files to be included in index files but typically you should leave as the default which is to include all JS and TS files. Continue without setting explicit whitelist?`
  ) : await askConfirmQuestion(
    `- you have whitelists currently in your configuration; can we keep these ${chalk18.italic`as is`}?`
  );
  if (!confirmWhitelist) {
    console.log(`- whitelists should be in a CSV format that can be parsed.`);
    console.log(`  for example ${chalk18.dim(` [ "**foobar.ts" ] `)}.`);
    whitelistGlobs = JSON.parse(await askInputQuestion(`pattern:`));
  }
  const confirmBlacklist = blacklistGlobs ? !await askConfirmQuestion(
    `- currently you have no files "blacklisted". Do you want to add any?`,
    { default: false }
  ) : await askConfirmQuestion(
    `- you have blacklists in your configuration; can we keep these ${chalk18.italic`as is`}?`
  );
  if (!confirmBlacklist) {
    console.log(`- blacklists should be in a CSV format that can be parsed.`);
    console.log(`  for example ${chalk18.dim(["**foobar.ts"])}.`);
    blacklistGlobs = JSON.parse(await askInputQuestion(`pattern:`));
  }
  const sfc = o.has("vue") ? true : false;
  await saveProjectConfig({
    autoindex: {
      indexGlobs,
      whitelistGlobs,
      blacklistGlobs,
      sfc
    }
  });
  log.info(`- ${"\u{1F389}" /* party */} configuration for ${chalk18.blue`autoindex`} has been saved to project`);
}

// src/shared/interactive/specific/images/askAddImageRule.ts
import chalk20 from "chalk";

// src/shared/data/csvParser.ts
function booleanChecker(v) {
  return v === "true" ? true : v === "false" ? false : v;
}
function numericChecker(v) {
  return Number.isNaN(Number(v)) ? v : Number(v);
}
function arrayChecker(v) {
  return typeof v === "string" && v.startsWith("[") && v.endsWith("]") ? v.replace(/(\[])/g, "").trim().split("|").map((i) => booleanChecker(numericChecker(i))) : v;
}
function prepArrayValues(input) {
  const re = /\[([^\]]*)]/g;
  const matches = [...input.matchAll(re)].map((i) => i[0]);
  for (const match of matches) {
    input = input.replace(match, match.replace(/,\s*/g, "|"));
  }
  return input;
}
function csvParser(input, options15 = {}) {
  const props = {
    nameProp: "name",
    valueProp: "value",
    ...options15
  };
  input = prepArrayValues(input);
  return input.split(/,\s*/).map((i) => {
    let [name, value] = i.split("::");
    name = name.trim();
    if (!value) {
      value = input.includes("::") ? "" : name;
    }
    value = arrayChecker(booleanChecker(numericChecker(value)));
    return { [props.nameProp]: name, [props.valueProp]: value };
  });
}

// src/shared/interactive/specific/images/askImageConfiguration.ts
import chalk19 from "chalk";
import { exit as exit3 } from "process";
async function askImageConfiguration(o, api) {
  const log = logger();
  log.info(`Welcome back, your ${chalk19.bold.yellow`image`} configuration summary is:
`);
  log.info(chalk19.bold.yellow`Rules:`);
  if (!o.has("image-cache")) {
    log.info(`- ${"\u{1F440}" /* eyeballs */} there is no image cache yet so no summary info is available.`);
  } else {
    await api.summarize();
    log.info();
  }
  const action = await askListQuestion(`What configuration operation are you interested in?`, [
    "Add Rule",
    "Remove Rule",
    "Change Rule",
    "Manage Defaults",
    "Quit"
  ]);
  const actionMap = {
    "Add Rule": askAddImageRule,
    "Remove Rule": askRemoveImageRule,
    "Change Rule": askChangeImageRule,
    "Manage Defaults": askImageDefaults,
    Quit: async () => {
      log.info("exiting ...");
      exit3(0);
    }
  };
  await actionMap[action](o, api);
}

// src/shared/interactive/specific/images/askAddImageRule.ts
var filter = (v) => !v.startsWith(".") && v !== "node_modules";
async function askAddImageRule(o, api) {
  const log = logger();
  const config = getProjectConfig().image;
  const rule = {};
  rule.name = await askInputQuestion(`What will the new rule be called:`);
  rule.source = await askForNestedDirectory(
    wordWrap(`What is the root directory for ${chalk20.bold.blue`source images`}?`),
    { name: "Source Directory", filter, leadChoices: [config.sourceDir] }
  );
  rule.destination = await askForNestedDirectory(
    `What is the root directory for ${chalk20.bold.blue`destination images`}?`,
    { name: "Destination Directory", filter, leadChoices: [config.destinationDir] }
  );
  rule.glob = await askInputQuestion(
    wordWrap(`What is the ${chalk20.italic`glob pattern`} used to identify the images: `)
  );
  const sizeOptions = [
    "high-quality [ 1024, 1280, 1536, 2048, 2560 ]",
    "full-width [ 640, 768, 1024, 1280, 1536 ]",
    "half-width [ 320, 384, 512, 640, 768 ]",
    "quarter-width [ 160, 192, 256, 320, 384 ]",
    "icon [ 128, 192, 256, 512 ]",
    "custom"
  ];
  const sizeName = await askListQuestion(
    wordWrap(`What are the sizes you want to convert to?`),
    sizeOptions,
    { default: "full-width [ 640, 768, 1024, 1280, 1536 ]" }
  );
  if (sizeName === "custom") {
    const customName = await askInputQuestion(`Add your own values as CSV (e.g., "64,128,256"):`);
    rule.widths = csvParser(customName);
  } else {
    rule.widths = JSON.parse(sizeName.replace(/.*\[/, "["));
  }
  rule.preBlur = await askConfirmQuestion(
    `Should images have a small blurred image produced for pre-loading?`
  );
  rule.metaDetail = await askListQuestion(
    `What level of detail will this rule need for metadata?`,
    ["basic", "categorical", "tags"]
  );
  rule.sidecarDetail = await askListQuestion(
    wordWrap(`Choose whether you want a sidecar meta file:`),
    ["none", "per-image", "per-rule"],
    { default: "none" }
  );
  await saveProjectConfig("image.rules", [...config.rules, rule]);
  log.info(`- your new rule named "${rule.name}", has been added to project configuration`);
  log.info();
  return askImageConfiguration(o, api);
}

// src/shared/interactive/specific/images/askChangeImageRule.ts
import { exit as exit4 } from "process";
async function askChangeImageRule(o, api) {
  const log = logger();
  let rule = api.rules.length === 1 ? api.rules[0] : await askListQuestion(
    `Which rule do you want to change?`,
    api.rules.map((i) => i.name)
  );
  if (typeof rule === "string") {
    rule = api.rules.find((i) => i.name === rule);
  }
  if (!rule) {
    log.shout("No rule was selected! Exiting");
    exit4(1);
  }
  return askImageConfiguration(o, api);
}

// src/shared/interactive/specific/images/askConfigureImageOptimization.ts
import chalk27 from "chalk";
import path17 from "path";

// src/shared/images/getImages.ts
import { globbySync as sync2 } from "globby";
function getImages(dir) {
  return sync2(
    [
      "**/*.gif",
      "**/*.jpg",
      "**/*.jpeg",
      "**/*.png",
      "**/*.avif",
      "**/*.webp",
      "**/*.tiff",
      "**/*.heif"
    ],
    { cwd: dir, onlyFiles: true, gitignore: true }
  );
}

// src/shared/images/useExifTools.ts
import chalk21 from "chalk";
import { exiftool } from "exiftool-vendored";

// src/shared/images/useExifTool/conversion-tools.ts
import { ExifDateTime } from "exiftool-vendored";
function convertExifDateToExifDataString(d) {
  return isExifDate(d) ? ExifDateTime.fromISO(d.toISOString()) : d;
}
function convertToExifDateTime(d) {
  if (!d) {
    return void 0;
  } else if (isExifDate(d)) {
    d = convertExifDateToExifDataString(d);
  } else if (typeof d === "string") {
    d = ExifDateTime.fromISO(d);
  }
  return d;
}
function reduceFl35(input) {
  if (!input) {
    return input;
  }
  const re = /:(.*)\)/;
  const matched = input.match(re);
  return matched ? matched[1] : input;
}
function improveMetaResults(meta) {
  return { ...meta };
}

// src/shared/images/useExifTool/metaCategories.ts
function metaReducer(meta) {
  const populated = Object.keys(meta).filter(Boolean);
  const make = [meta.DeviceManufacturer, meta.CameraID, meta.Make, meta.VendorID].filter((i) => i ? true : false).pop();
  const model = [
    meta.Model,
    meta.ModelAndVersion,
    meta.CameraModel,
    meta.CameraModelID,
    meta.CameraType,
    meta.SonyModelID,
    meta.CanonModelID,
    meta.KodakModel,
    meta.RicohModel,
    meta.CameraModel,
    meta.CameraModelID,
    meta.DeviceModelDesc,
    meta.GEModel,
    meta.PentaxModelID,
    meta.MinoltaModelID,
    meta.SamsungModelID,
    meta.UniqueCameraModel
  ].filter(Boolean).pop();
  const color = [
    meta.ProfileDescription,
    meta.ICCProfileName,
    meta.DeviceModel,
    meta.Look?.name ? String(meta.Look?.name) : void 0
  ].filter(Boolean).pop();
  const software = [meta.Software, meta.CameraSoftware].filter(Boolean).pop();
  const shutterSpeed = [
    meta.ShutterSpeed,
    meta.ShutterSpeedValue,
    meta.Shutter,
    meta.SpeedX,
    meta.SpeedY,
    meta.SpeedZ
  ].filter(Boolean).pop();
  const iso = [
    meta.ISO,
    meta.ISO2,
    meta.ISOSetting,
    meta.ISOSpeed,
    meta.ISOValue,
    meta.SonyISO,
    meta.BaseISO,
    meta.SvISOSetting,
    meta.BaseISO
  ].filter(Boolean).pop();
  const dateOptions = [
    meta.DateAcquired,
    meta.DateTime,
    meta.DateTime1,
    meta.DateTimeCreated,
    meta.DateTimeDigitized,
    meta.DateTimeOriginal,
    meta.GPSDateTime,
    meta.SonyDateTime,
    meta.PanasonicDateTime,
    meta.RicohDate,
    meta.DateCreated,
    meta.Date
  ].filter(Boolean).pop();
  const createDate = convertToExifDateTime(dateOptions);
  const modifyDate = convertToExifDateTime(
    [meta.ModifyDate, meta.ModificationDate].filter(Boolean).pop()
  );
  const height = [
    meta.ImageHeight,
    meta.RawImageHeight,
    meta.ExifImageHeight,
    meta.SonyImageHeight,
    meta.EpsonImageHeight,
    meta.SourceImageHeight,
    meta.CanonImageHeight,
    meta.KodakImageHeight,
    meta.RicohImageHeight,
    meta.OlympusImageHeight,
    meta.PanoramaFullHeight,
    meta.PanasonicImageHeight,
    meta.RawImageFullHeight
  ].filter(Boolean).pop();
  const width = [
    meta.ImageWidth,
    meta.ExifImageWidth,
    meta.RawImageWidth,
    meta.SonyImageWidth,
    meta.SourceImageWidth,
    meta.CanonImageWidth,
    meta.KodakImageWidth,
    meta.RicohImageWidth,
    meta.OlympusImageWidth,
    meta.PanasonicImageWidth,
    meta.PanoramaFullWidth,
    meta.RawImageFullWidth
  ].filter(Boolean).pop();
  const aperture = [meta.Aperture, meta.ApertureSetting].filter(Boolean).pop();
  const lens = [meta.LensID, meta.Lens, meta.LensInfo, meta.LensModel].filter(Boolean).pop();
  const lensMake = [meta.LensMake, meta.KodakMake].filter(Boolean).pop();
  const focalLength = [meta.FocalLength, [meta.FocalType, meta.FocalUnits].join("")].filter(Boolean).pop();
  const focalLength35 = [meta.FocalLengthIn35mmFormat, reduceFl35(meta.FocalLengthIn35mmFormat)].filter(Boolean).pop()?.trim();
  const exposureProgram = [meta.ExposureProgram, meta.AEProgramMode].filter(Boolean).pop();
  const bracketing = meta.BracketProgram;
  const exposureMode = [meta.ExposureMode].filter(Boolean).pop();
  const exposureBias = [meta.Exposure, meta.ExposureCompensation, meta.ExposureBracketValue].filter(Boolean).pop();
  const meteringMode = [meta.MeterMode, meta.Metering].filter(Boolean).pop();
  const flash = [
    meta.Flash,
    meta.FlashAction,
    meta.FlashFunction,
    meta.FlashControl,
    meta.FlashFired
  ].filter(Boolean).pop();
  const flashCompensation = [meta.FlashCompensation, meta.FlashBias].filter(Boolean).pop();
  const brightness = [meta.Brightness, meta.BrightnessValue].filter(Boolean).pop();
  const scene = [
    meta.Scene,
    meta.SceneAssist,
    meta.SceneCaptureType,
    meta.SceneMode,
    meta.SceneModeUsed,
    `${String(meta.SceneDetect)} scene id`
  ].filter(Boolean).pop();
  const subjectDistance = meta.SubjectDistance;
  const sharpness = String(
    [meta.Sharpness, meta.SharpnessFactor, meta.SharpnessSetting, meta.SharpnessRange].filter(Boolean).pop()
  );
  const dpi = meta.XResolution && meta.YResolution ? [meta.XResolution, meta.YResolution] : void 0;
  const gps = {
    altitude: [meta.GPSAltitude ? String(meta.GPSAltitude) : void 0, meta.GPSAltitudeRef].filter(Boolean).pop(),
    coordinates: [[meta.GPSLatitude, meta.GPSLongitude], meta.GPSCoordinates].filter(Boolean).pop(),
    latitudeReference: meta.GPSLatitudeRef?.toUpperCase(),
    longitudeReference: meta.GPSLongitudeRef?.toUpperCase(),
    destination: meta.GPSDestLatitude && meta.GPSDestLongitude ? [Number(meta.GPSDestLatitude || 0), Number(meta.GPSDestLongitude || 0)] : void 0
  };
  const title = [meta.Title, meta.XPTitle, meta["By-lineTitle"]].filter(Boolean).pop();
  const caption = [meta["Caption-Abstract"], meta.LocalCaption, meta.CanonFileDescription].filter(Boolean).pop();
  const copyright = [meta.Copyright, meta.CopyrightNotice].filter(Boolean).pop();
  const megapixels = meta.Megapixels;
  const rating = [meta.Rating, meta.RatingPercent].filter(Boolean).pop();
  const subject = [meta.Subject?.pop(), meta.SubjectReference].filter(Boolean).pop();
  const location = {
    city: meta.City,
    state: meta.State,
    location: meta.LocationName,
    country: meta.country ? String(meta.country) : void 0,
    countryCode: meta.CountryCode
  };
  return {
    populated,
    make,
    model,
    color,
    shutterSpeed,
    iso,
    createDate,
    modifyDate,
    height,
    width,
    software,
    aperture,
    lens,
    lensMake,
    focalLength,
    focalLength35,
    exposureMode,
    exposureBias,
    flash,
    flashCompensation,
    brightness,
    scene,
    subject,
    subjectDistance,
    sharpness,
    dpi,
    gps,
    title,
    caption,
    copyright,
    megapixels,
    rating,
    exposureProgram,
    bracketing,
    location,
    meteringMode,
    errors: meta.errors || []
  };
}

// src/shared/images/useExifTools.ts
var cache = {};
async function removeOriginalFile(file) {
  const original = `${file}_original`;
  console.log("removing:", original);
  removeFile(original);
}
async function refreshCache(image, returnMeta, payload) {
  if (returnMeta) {
    if (cache[image]) {
      cache[image] = { ...cache[image], ...payload };
    } else {
      await useExifTools().getMetadata(image, true);
    }
  } else {
    cache[image] = { ...cache[image], ...payload };
  }
}
function useExifTools(options15 = {}) {
  const _o = {
    ...options15
  };
  const api = {
    version: async () => {
      return exiftool.version();
    },
    getMetadata: async (file, force = false) => {
      if (Object.keys(cache).includes(file) && !force) {
        return cache[file];
      }
      const meta = improveMetaResults(await exiftool.read(file));
      cache[file] = meta;
      return meta;
    },
    removeAllMeta: async (image, keepOriginalCopy = false) => {
      await exiftool.deleteAllTags(image).catch((error) => {
        if (error.message.includes("No success message")) {
          console.log(
            `- possible failure removing tags from "${image}" but this error message can often be ignored.`
          );
        } else {
          throw error;
        }
      });
      if (cache[image]) {
        cache[image] = {};
      }
      if (!keepOriginalCopy) {
        removeOriginalFile(image);
      }
    },
    addTag: async (file, tag, value, keepOriginalCopy = false) => {
      if (!cache[file]) {
        await useExifTools(_o).getMetadata(file);
      }
      if (cache[file][tag] !== void 0) {
        throw new DevopsError(
          `Attempt to add "${tag}" on the image ${chalk21.blue(file)} failed as this property already exists; use setTag() instead if you want to be able to overwrite.`,
          "exif-tool/tag-exists"
        );
      }
      await exiftool.write(file, { [tag]: value });
      cache[file] = { ...cache[file], [tag]: value };
      if (!keepOriginalCopy) {
        removeOriginalFile(file);
      }
      return cache[file];
    },
    addContactInfo: async (file, contactInfo, returnMeta = false, keepOriginalCopy = false) => {
      return await api.setTags(
        file,
        { CreatorContactInfo: contactInfo },
        returnMeta,
        keepOriginalCopy
      );
    },
    setTags: async (image, tags, returnMeta = false, keepOriginalCopy = false) => {
      await exiftool.write(image, tags);
      await refreshCache(image, returnMeta, tags);
      const results = returnMeta ? cache[image] : void 0;
      if (!keepOriginalCopy) {
        removeOriginalFile(image);
      }
      return results;
    },
    removeTags: async (image, tags, returnMeta = false, keepOriginalCopy = false) => {
      if (!Array.isArray(tags)) {
        tags = [tags];
      }
      const eraser = tags.reduce((acc, item) => {
        acc = { ...acc, [item]: void 0 };
        return acc;
      }, {});
      await exiftool.write(image, eraser);
      await refreshCache(image, returnMeta, eraser);
      const results = returnMeta ? cache[image] : void 0;
      if (!keepOriginalCopy) {
        removeOriginalFile(image);
      }
      return results;
    },
    addCopyright: async (image, message, returnMeta = false, keepOriginalCopy = false) => {
      const payload = {
        Copyright: message,
        CopyrightNotice: message
      };
      const result = await api.setTags(image, payload, returnMeta, keepOriginalCopy);
      await refreshCache(image, returnMeta, payload);
      return result;
    },
    setTitle: async (image, title, returnMeta = false, keepOriginalCopy = false) => {
      const payload = {
        Title: title,
        XPTitle: title
      };
      await exiftool.write(image, payload);
      await refreshCache(image, returnMeta, payload);
      if (!keepOriginalCopy) {
        removeOriginalFile(image);
      }
      return returnMeta ? cache[image] : void 0;
    },
    categorizedMetadata: async (file) => {
      if (!cache[file]) {
        await useExifTools(_o).getMetadata(file);
      }
      return metaReducer(cache[file]);
    },
    close: async () => {
      return exiftool.end();
    }
  };
  return api;
}

// src/shared/images/useImageApi.ts
import chalk26 from "chalk";
import destr from "destr";

// src/shared/images/useImageApi/convertStale.ts
import chalk24 from "chalk";

// src/shared/images/useImageApi/checkCacheFreshness.ts
import chalk22 from "chalk";
import { globby as globby4 } from "globby";
import { join as join8 } from "path";
async function checkCacheFreshness(cache2, rule) {
  const log = logger();
  const baseDir = rule.source;
  const globPattern = rule.glob;
  const targetFiles = (await globby4(globPattern, {
    cwd: join8(repoDirectory(), baseDir),
    onlyFiles: true,
    stats: true,
    caseSensitiveMatch: false
  })).map((i) => ({ name: join8(baseDir, i.path), modified: i.stats.mtimeMs }));
  const missing = [];
  const outOfDate = [];
  for (const file of targetFiles) {
    const cacheRef = cache2.source[file.name];
    if (!Object.keys(cache2.source).includes(file.name)) {
      missing.push(file.name);
    } else if (cacheRef.modified < file.modified) {
      outOfDate.push(file.name);
    }
  }
  log.whisper(
    chalk22.dim`- there were {bold ${targetFiles.length}} source images discovered for the ${chalk22.blue(rule.name)} rule. Of which ${missing.length} were ${chalk22.italic`missing`} from the cache and ${outOfDate.length} were in the cache but stale.`
  );
  return { missing, outOfDate };
}

// src/shared/images/useImageApi/refreshCache.ts
import chalk23 from "chalk";
import { format } from "date-fns";

// src/shared/images/useImageApi/buildTagsFromCache.ts
function buildTagsFromCache(tags, cache2, sourceFile) {
  return tags.reduce((acc, tag) => {
    const c = cache2.source[sourceFile];
    acc = { ...acc, [tag]: c.meta[tag] };
    return acc;
  }, {});
}

// src/shared/images/useImageApi/saveImageCache.ts
function saveImageCache(cache2) {
  write2(IMAGE_CACHE, JSON.stringify(cache2), { allowOverwrite: true });
}

// src/shared/images/useImageApi/refreshCache.ts
async function refreshCache2(rule, tools, stale) {
  const log = logger();
  const sourceImages = [];
  const optimizedImages = [];
  const now = Date.now();
  for (const file of stale) {
    sourceImages.push(
      Promise.all([
        tools.sharp.getMetadata(file).then(
          (m) => ({
            file,
            created: tools.cache.source[file]?.created || now,
            modified: now,
            isSourceImage: true,
            rule: rule.name,
            size: m.size,
            width: m.width,
            height: m.height,
            metaDetailLevel: "basic",
            sharpMeta: m
          })
        ),
        rule.metaDetail === "basic" ? Promise.resolve() : rule.metaDetail === "categorical" ? tools.exif.categorizedMetadata(file) : tools.exif.getMetadata(file)
      ])
    );
    optimizedImages.push(tools.sharp.resizeToWebFormats(file, rule.destination, rule.widths));
  }
  const sis = await Promise.all(sourceImages);
  for (const si of sis) {
    const [cacheRef, exifMeta] = si;
    tools.cache.source[cacheRef.file] = {
      ...cacheRef,
      meta: exifMeta,
      metaDetailLevel: rule.metaDetail
    };
  }
  const optimized = (await Promise.all(optimizedImages)).flat().map(
    (i) => ({
      ...i,
      rule: rule.name,
      isSourceImage: false,
      metaDetailLevel: "basic",
      meta: {}
    })
  );
  for (const f of optimized) {
    tools.cache.converted[f.file] = f;
  }
  saveImageCache(tools.cache);
  log.info(
    `- ${"\u{1F44D}" /* thumbsUp */} image cache saved to disk with updated source and converted images`
  );
  log.whisper(
    chalk23.dim`using the "${rule.name}" rule, {bold ${optimized.length}} images have been resized using Sharp to fit "web formats"`
  );
  if (rule.preBlur) {
    const waitBlurry = [];
    for (const file of stale) {
      waitBlurry.push(tools.sharp.blurredPreImage(file, rule.destination));
    }
    const blurred = await Promise.all(waitBlurry);
    log.whisper(
      chalk23.dim`- produced a blurred image preload for ${blurred.length} images associated to "${rule.name}" rule`
    );
  }
  const metaMessages = [];
  if (rule.preserveMeta) {
    metaMessages.push(
      "all meta data from the original image was removed and a web friendly sRGB color profile was added to the converted image"
    );
  } else {
    metaMessages.push(
      "all meta data from the original image will be preserved in the converted image",
      "note that colorspace profile was converted to sRGB in conversion process and this will not be reverted back"
    );
  }
  if (rule.copyright) {
    metaMessages.push(
      "a copyright notice was associated to this rule and will be applied to converted images"
    );
  }
  log.whisper(
    `- looking at metadata requirements for the optimized images; will apply the following policy:
    - ${metaMessages.join(
      "\n    - "
    )}`
  );
  if (rule.preserveMeta && rule.preserveMeta.length > 0) {
    const metaTransfers = [];
    for (const file of optimized) {
      if (!file.from) {
        throw new DevopsError(
          `Attempt to bring metadata over to "${file.file}" file failed as the 'from' property in the cache was not populated!`,
          "image/not-ready"
        );
      }
      const cacheEntry = tools.cache.source[file.from];
      if (!cacheEntry) {
        throw new DevopsError(
          `Failed to bring metadata over to "${file.file}" file because there was no cache entry for the source image: ${file.from}`
        );
      }
      metaTransfers.push(
        tools.exif.setTags(file.file, buildTagsFromCache(rule.preserveMeta, tools.cache, file.from))
      );
    }
    await Promise.all(metaTransfers);
    log.whisper(
      `- Metadata properties -- ${chalk23.italic(rule.preserveMeta.join(", "))} -- have been added to the web images where they were available in the source image`
    );
  }
  if (rule.copyright) {
    const cpPromises = [];
    for (const file of optimized) {
      cpPromises.push(tools.exif.addCopyright(file.file, rule.copyright));
    }
    await Promise.all(cpPromises);
    log.whisper(
      `- copyright notices have been applied to the ${chalk23.yellow.bold(optimized.length)} images which were created as a result of recent changes to source files`
    );
  }
  log.info(
    `- ${"\u{1F389}" /* party */} all images are now up-to-date based on recent source image changes [ ${chalk23.dim(format(
      Date.now(),
      "h:mm:ss aaaa"
    ))} ]`
  );
}

// src/shared/images/useImageApi/createTsSupportFile.ts
var TS_IMAGE_SUPPORT_FILE = `src/images/optimized-images.ts`;
function createTsSupportFile(rules, tools) {
  const lookups = {};
  for (const key of Object.keys(tools.cache.source)) {
    const si = tools.cache.source[key];
    const rule = rules.find((i) => i.name === si.rule);
    const parts = getFileComponents(si.file);
    lookups[parts.fileWithoutExt] = {
      name: parts.fileWithoutExt,
      widths: rule.widths,
      formats: ["jpg", "png", "webp"],
      path: parts.filepath,
      aspectRatio: si.width / si.height
    };
  }
  const file = `
  import type { IOptimizedImage } from "common-types";

  /** 
   * a key/value lookup of available optimized images where the _key_ is
   * the name of the image without 
   */
  export const OptimizedImageLookup: Record<string, IOptimizedImage> = ${JSON.stringify(
    lookups,
    null,
    2
  )}  as const;
  
  export interface IOptimizedImages = keyof typeof OptimizedImageLookup;
  export enum OptimizedImage {

  };

  `;
  write2(TS_IMAGE_SUPPORT_FILE, file);
}

// src/shared/images/useImageApi/convertStale.ts
async function convertStale(rules, tools, _options) {
  const log = logger();
  const config = getProjectConfig().image;
  for (const [i, rule] of rules.entries()) {
    log.info(
      `- checking rule ${chalk24.blue(rule.name)}} for stale source images [ ${chalk24.dim(i + 1)} ${chalk24.italic`of`} ${rules.length}} ]`
    );
    const { missing, outOfDate } = await checkCacheFreshness(tools.cache, rule);
    if (missing.length > 0) {
      log.whisper(
        chalk24.dim`there are ${chalk24.bold(missing.length)} images not currently in the cache: ${missing.join(", ")}`
      );
    }
    if (outOfDate.length > 0) {
      log.whisper(
        `- there are ${outOfDate.length} images who are out of date: ${chalk24.dim(missing.join(
          ", "
        ))}`
      );
    }
    if (missing.length === 0 && outOfDate.length === 0) {
      log.info(
        `- ${"\u{1F389}" /* party */} all images in ${chalk24.blue(rule.name)} are current; no work needed.`
      );
      log.info(chalk24.dim`- if you need to force image production use ${chalk24.blue`dd optimize --force`}`);
    } else {
      await refreshCache2(rule, tools, [...missing, ...outOfDate]);
      const changes = [...missing, ...outOfDate];
      const resized = [];
      for (const img of changes) {
        resized.push(
          tools.sharp.resizeToWebFormats(img, rule.destination, rule.widths, {
            ...rule.options,
            includePNG: rule.outputPNG
          })
        );
      }
      const resizedComplete = (await Promise.all(resized)).flat();
      log.whisper(
        chalk24.dim`- the following images were ${chalk24.italic`resized`}:\n${wordWrap(
          resizedComplete.map((i2) => i2.file).join("	"),
          { wrapDistance: 120 }
        )}\n`
      );
    }
  }
  if (config?.supportTS) {
    createTsSupportFile(rules, tools);
  }
}

// src/shared/images/useImageApi/watchForChange.ts
async function watchForChange(_rules, _tools, _options) {
}

// src/shared/images/useImageApi/summarize.ts
import chalk25 from "chalk";
import { formatDistance as formatDistance2 } from "date-fns";
function summarize(rules, tools) {
  const log = logger();
  if (!tools.cache) {
    log.shout(
      `- ${"\u{1F440}" /* eyeballs */} there is no image cache; do you want to run {dd image convert} first?`
    );
  }
  if (!tools.cache.source) {
    console.log(
      wordWrap(
        `- ${"\u{1F440}" /* eyeballs */} there appears to be something wrong with your image cache as the cache file does exist but the "source" folder is missing. Please have a look but it is probably best that you re-build the cache with ${chalk25.blue`dd image optimize --force`}`
      )
    );
    process.exit();
  }
  const sourceImages = Object.keys(tools.cache.source).reduce((acc, i) => {
    acc = [...acc, tools.cache.source[i]];
    return acc;
  }, []);
  const convertedImages = Object.keys(tools.cache.converted).reduce((acc, i) => {
    acc = [...acc, tools.cache.converted[i]];
    return acc;
  }, []);
  const lastUpdate = formatDistance2(
    sourceImages.reduce((mostRecent, i) => i.modified > mostRecent ? i.modified : mostRecent, 0),
    Date.now(),
    { addSuffix: true }
  );
  log.info(`{bold Summary of Image Configuration}`);
  log.info(`{bold ------------------------------}
`);
  log.info(`- there are ${chalk25.yellow.bold(sourceImages.length)} source images in the cache`);
  log.info(`- the last detected change in these source images was ${lastUpdate}`);
  log.info(
    chalk25.dim(` - the rules ${chalk25.italic("plus")} source images have produced ${chalk25.yellowBright(convertedImages.length)} optimized images})`)
  );
  log.info();
  log.info(`  Rule Overview:`);
  log.info(`  --------------`);
  for (const r of rules || []) {
    const sourceFromRule = sourceImages.filter((i) => i?.rule === r.name);
    const convertedFromRule = convertedImages.filter((i) => i?.rule === r.name);
    log.info(
      `    - ${r.name}: ${chalk25.dim(" source: ")}${chalk25.gray(r.source)}}${chalk25.gray`"`}, destination: }${chalk25.gray`"`}${r.destination}}${chalk25.gray`"`}, glob: }${chalk25.gray`"`}${r.glob}${chalk25.gray`"`}, source images: ${sourceFromRule.length}, optimized images: ${convertedFromRule.length}`
    );
  }
}

// src/shared/images/useSharp.ts
import { omit as omit2 } from "native-dash";
import { join as join9 } from "path";
import sharp from "sharp";

// src/errors/ImageError.ts
import { createError } from "brilliant-errors";
var [ImageError] = createError("ImageError", "do-devops")(
  "format",
  "io",
  "conversion"
)()()();

// src/shared/images/useSharp.ts
function outFilename(dir, name, width, format6) {
  return join9(dir, `${name}-${width}.${format6}`);
}
function useSharp(options15 = {}) {
  const o = {
    simd: true,
    jpg: {
      quality: 60,
      mozjpeg: true,
      progressive: true
    },
    avif: {
      quality: 30
    },
    webp: {
      quality: 40
    },
    heif: {
      quality: 60
    },
    ...options15
  };
  if (o.simd) {
    const result = sharp.simd();
    if (!result) {
      console.log(
        `- Sharp attempted to establish use of simd acceleration but hardware platform did not allow it.`
      );
    }
  }
  const api = {
    resizeImage: async (image, outDir, width, format6, options16 = {}) => {
      const name = getFileComponents(image).fileWithoutExt;
      const out = outFilename(outDir, name, width, format6);
      return sharp(image).toFormat(format6, options16).resize(width).toFile(out).then((info2) => {
        const now = Date.now();
        return {
          file: out,
          created: now,
          modified: now,
          size: info2.size,
          width: info2.width,
          height: info2.height,
          isSourceImage: false,
          from: image,
          metaDetailLevel: "basic",
          sharpMeta: info2,
          meta: void 0
        };
      }).catch((error) => {
        throw new ImageError(`Problem writing file ${out}! ${error.message}`, "io/saving-image");
      });
    },
    getMetadata: async (source) => {
      return sharp(source).metadata().then((meta) => {
        return omit2(meta, "exif", "iptc", "icc", "xmp");
      });
    },
    resizeToWebFormats: async (source, outDir, width, options16 = {}) => {
      if (!Array.isArray(width)) {
        width = [width];
      }
      const promises = [];
      for (const w2 of width) {
        promises.push(
          api.resizeImage(source, outDir, w2, "jpg", { ...o.jpg, ...options16 }),
          api.resizeImage(source, outDir, w2, "avif", { ...o.avif, ...options16 }),
          api.resizeImage(source, outDir, w2, "webp", { ...o.webp, ...options16 })
        );
        if (options16.includePNG) {
          promises.push(api.resizeImage(source, outDir, w2, "png", { ...o.png, ...options16 }));
        }
      }
      return Promise.all(promises);
    },
    blurredPreImage: async (image, outDir, size = 32) => {
      const s = getFileComponents(image);
      const baseName = `${s.fileWithoutExt}-blurred.jpg`;
      const blurFilename = join9(outDir, baseName);
      await sharp(image).toFormat("jpg", { mozjpeg: true, progressive: true }).blur(true).resize({ width: size }).toFile(blurFilename);
      return baseName;
    }
  };
  return api;
}

// src/shared/images/useImageApi.ts
function useImageApi(rules, options15 = {}) {
  const log = logger();
  const exif = useExifTools();
  const sharp2 = useSharp();
  const cacheFileExists = fileExists(IMAGE_CACHE);
  log.whisper(
    cacheFileExists && options15.clearCache !== true ? chalk26.dim`- cache file found on disk, loading ...` : options15.clearCache === true ? chalk26.dim`- starting with clean cache due to "clearCache" flag` : chalk26.dim`- no cache file found on disk, will start with clean cache`
  );
  const cache2 = cacheFileExists && options15.clearCache !== true ? destr(readFile(IMAGE_CACHE)) : { source: {}, converted: {} };
  const tools = { exif, sharp: sharp2, cache: cache2 };
  const api = {
    rules,
    watch: async () => {
      await convertStale(rules, tools, options15);
      await watchForChange(rules, tools, options15);
    },
    convert: async () => {
      await convertStale(rules, tools, options15);
    },
    summarize: async () => {
      return summarize(rules, tools);
    },
    getMetaForImage: async (image, format6 = "tags") => {
      return format6 === "tags" ? exif.getMetadata(image) : exif.categorizedMetadata(image);
    },
    close: async () => {
      return exif.close();
    }
  };
  return api;
}

// src/shared/interactive/specific/images/askConfigureImageOptimization.ts
var filter2 = (v) => !v.startsWith(".") && v !== "node_modules";
async function askConfigureImageOptimization(_o) {
  const log = logger();
  const images = getImages(currentDirectory());
  const imageDirs = /* @__PURE__ */ new Set();
  for (const i of images) {
    imageDirs.add(path17.dirname(i));
  }
  log.shout(
    wordWrap(
      `Welcome weary traveler! It appears you've not configured ${chalk27.bold.blue`images`} for this repo before. Let's get that out of the way now.
`
    )
  );
  const sourceDir = await askForNestedDirectory(
    wordWrap(
      `You are expected to choose a ${chalk27.blue`source directory`} to act as the ${chalk27.italic`default`} dir for all your rule's source images. Choose from the directories below (${chalk27.italic`dirs with image will be at top of list`}):`
    ),
    {
      name: "Source Directory",
      filter: filter2,
      leadChoices: [...imageDirs]
    }
  );
  log.info();
  const destinationDir = await askForNestedDirectory(
    wordWrap(
      `Now choose a ${chalk27.italic`default`} ${chalk27.blue`destination directory`} for images; ${chalk27.bold`rules`} will still need choose this too but they'll default to whatever you choose.

`
    ) + wordWrap(
      `Note: the most common directory to target would be the ${chalk27.blue`/public`} directory as this is typically where build tools look for static assets like images.`
    ) + `

Choose from list:`,
    {
      name: "Destination Directory",
      filter: filter2,
      leadChoices: ["public"]
    }
  );
  log.info();
  log.shout(
    wordWrap(
      `The ${chalk27.italic`general`} configuration of the image service is now complete but ${chalk27.italic`rules`} are a key component of having a complete setup. For this reason we will add one rule now and if you want to add more later simply run ${chalk27.blue`dd image config`} again and choose "add rule" from the options.

`
    )
  );
  const rule = {};
  rule.name = await askInputQuestion(
    `Each rule needs to have a "name" to identify it (you can change later without issue):`
  );
  rule.source = await askForNestedDirectory(
    wordWrap(
      `Each rule must state a root directory for their ${chalk27.bold.blue`source`} images;
it is already defaulted to the general setting you chose earlier but if this rule should start somewhere else feel free to change`
    ),
    { name: "Rule Source Directory", filter: filter2, leadChoices: [sourceDir] }
  );
  rule.destination = await askForNestedDirectory(
    `Similarly, a rule has a default ${chalk27.bold.blue`destination`} directory`,
    { name: "Rule Destination Directory", filter: filter2, leadChoices: [destinationDir] }
  );
  rule.glob = await askInputQuestion(
    wordWrap(
      `Finally, a rule must express a "glob pattern" for picking up the images it sees as source images (the glob pattern will be applied in the source directory you just chose). An example glob pattern to find all PNG images recursively would be ${chalk27.bgWhite.blackBright(
        "**/*.png"
      )}: `
    )
  );
  const sizeOptions = [
    "high-quality [ 1024, 1280, 1536, 2048, 2560 ]",
    "full-width [ 640, 768, 1024, 1280, 1536 ]",
    "half-width [ 320, 384, 512, 640, 768 ]",
    "quarter-width [ 160, 192, 256, 320, 384 ]",
    "icon [ 128, 192, 256, 512 ]",
    "custom"
  ];
  const sizeName = await askListQuestion(
    wordWrap(
      `When a source image is optimized it will be converted to JPG, AVIF, and WebP formats but it will also be done in different sizes. There are a number of default options listed below which largely trigger off of two variables:
`
    ) + ` 1. the responsive breakpoints we use for responsive design
  2. the idea of what percentage the screen width the image will typically occupy

` + wordWrap(
      `Note:
  - some smaller displays ${chalk27.italic`do`} have much higher DPI so they can display high resolution;
  - also due to ${chalk27.italic`responsive design`} sometimes smaller displays take up more width on a percentage basis

Choose from the defaults or design your own:`
    ),
    sizeOptions,
    { default: "full-width [ 640, 768, 1024, 1280, 1536 ]" }
  );
  if (sizeName === "custom") {
    const customName = await askInputQuestion(`Add your own values as CSV (e.g., "64,128,256"):`);
    rule.widths = csvParser(customName);
  } else {
    rule.widths = JSON.parse(sizeName.replace(/.*\[/, "["));
  }
  rule.preBlur = await askConfirmQuestion(
    `Should images in this rule also generate a small blurred image for pre-loading?`
  );
  rule.metaDetail = await askListQuestion(
    `What level of detail will this rule need for metadata?`,
    ["basic", "categorical", "tags"]
  );
  rule.sidecarDetail = await askListQuestion(
    wordWrap(
      `Sometimes it's helpful to have a "sidecar" file which has meta data as a JSON. This could be a JSON file per directory or one per file. If you don't need it though -- in most cases you won't -- then just choose "none":`
    ),
    ["none", "per-image", "per-rule"],
    { default: "none" }
  );
  const rules = [rule];
  saveProjectConfig({
    image: {
      sourceDir,
      destinationDir,
      rules,
      defaultWidths: [640, 768, 1024, 1280, 1536],
      formatOptions: {
        jpg: { mozjpeg: true, quality: 60 },
        avif: { quality: 30 },
        webp: { quality: 40 }
      },
      sidecar: "none"
    }
  });
  log.info(
    `

Fantastic, you have default properties configured {bold plus} your first rule defined!
`
  );
  log.info(`- to convert images run ${chalk27.blue`dd image optimize`} and your rule will be executed.`);
  log.info(
    `- the ${chalk27.blue`.do-devop.json`} file in the root of the repo will host your configuration.`
  );
  log.info(
    `- you can always edit the config directly in the config file or if you prefer use the ${chalk27.blue`dd image config`} menu`
  );
  return { sourceDir, targetDir: destinationDir, rules };
}

// src/shared/interactive/specific/images/askImageDefaults.ts
import chalk28 from "chalk";
async function askImageDefaults(o, api) {
  const log = logger();
  const config = getProjectConfig().image;
  log.info(
    `Current settings for image can be found in the -- ${chalk28.blue(CONFIG_FILE)} ${chalk28.italic`file`} -- and are as follows:`
  );
  const options15 = [
    `sourceDir: ${config.sourceDir}`,
    `destinationDir: ${config.destinationDir}`,
    `defaultWidths: ${JSON.stringify(config.defaultWidths)}`,
    `formatOptions: ${JSON.stringify(config.formatOptions)}`,
    `sidecar: ${config.sidecar}`
  ];
  await askListQuestion(`Which of the following do you want to edit?`, options15);
  log.info();
  return askImageConfiguration(o, api);
}

// src/shared/interactive/specific/images/askRemoveImageRule.ts
async function askRemoveImageRule(o, api) {
  const log = logger();
  const config = getProjectConfig().image;
  const rule = await askListQuestion(
    `Which rule do you want to remove?`,
    api.rules.map((i) => i.name)
  );
  await saveProjectConfig(
    "image.rules",
    config.rules.filter((i) => i.name !== rule)
  );
  log.info(`- ${rule} has been removed from configuration`);
  return askImageConfiguration(o, api);
}

// src/shared/aws/askForAwsProfile.ts
async function askForAwsProfile(opts) {
  opts = opts ? { exitOnError: false, ...opts } : { exitOnError: false };
  const profiles = await getAwsProfileDictionary();
  if (!profiles) {
    const cont = askConfirmQuestion(
      `Currently you don't have any AWS profiles (aka, profiles in src/.aws/credentials).
Would you like to create one now?`
    );
    if (!cont) {
      console.log(`- no problem, try this command again when you're ready.
`);
      process.exit();
    }
  }
  const defaultProfile = opts.defaultProfile ? profiles[opts.defaultProfile] : profiles[0];
  const question = {
    name: "profile",
    type: "list",
    choices: Object.keys(profiles),
    message: "choose a profile from your AWS credentials file",
    default: defaultProfile,
    when: () => true
  };
  const answer = await inquirer3.prompt(question);
  return answer.profile;
}

// src/shared/aws/askForAwsRegion.ts
import inquirer4 from "inquirer";

// src/shared/aws/aws-type-guards.ts
function isAwsProfile(input) {
  return typeof input === "object" && input !== null && Object.keys(input).includes("aws_access_key_id") && Object.keys(input).includes("aws_secret_access_key");
}

// src/shared/aws/checkIfAwsInstalled.ts
import { asyncExec } from "async-shelljs";

// src/shared/aws/convertProfileToApiCredential.ts
function convertProfileToApiCredential(profile2) {
  if (!isAwsProfile(profile2)) {
    const isObject = typeof profile2 === "object" && profile2 !== null;
    throw new DevopsError(
      `The {bold {red IAwsProfile}} information which was passed in to be converted to {bold IAwsCredentials} data was malformed and can not be converted! To be valid a key it must have both {green aws_access_key_id} and {green aws_secret_access_key} defined. [${isObject ? "keys found were " + Object.keys(profile2).join(", ") : `wrong type: ${typeof profile2}`}]

`,
      "do-devops/invalid-aws-profile"
    );
  }
  return {
    accessKeyId: profile2.aws_access_key_id,
    secretAccessKey: profile2.aws_secret_access_key
  };
}

// src/shared/aws/aws-proxy.ts
import aws from "aws-sdk";
var { EC2, APIGateway, ApiGatewayV2, Lambda, StepFunctions, S3, STS, IAM } = aws;

// src/shared/aws/userHasAwsProfile.ts
async function userHasAwsProfile(profileName) {
  const profiles = Object.keys(await getAwsProfileDictionary());
  return profiles.includes(profileName);
}

// src/shared/aws/getApiGatewayEndpoints.ts
import chalk29 from "chalk";
async function getApiGatewayEndpoints(profileName, region) {
  if (!userHasAwsProfile(profileName)) {
    console.log(
      `- attempt to get ${chalk29.italic`endpoints`} not possible with the profile ${chalk29.blue`${profileName}`} as you do not have credentials defined for this profile! ${"\u{1F621}" /* angry */}
`
    );
    process.exit();
  }
  const profile2 = await getAwsProfile(profileName);
  const credential = convertProfileToApiCredential(profile2);
  const gw = new APIGateway({
    ...credential,
    region
  });
  const gw2 = new ApiGatewayV2({
    ...credential,
    region
  });
  const restApi = await gw.getRestApis().promise();
  const httpApi = await gw2.getApis().promise();
  return { httpApi, restApi };
}

// src/shared/aws/getAwsProfile.ts
async function getAwsProfile(profileName) {
  const profile2 = await getAwsProfileDictionary();
  if (!profile2) {
    throw new DevopsError(
      `Attempt to get the AWS profile "${profileName}" failed because the AWS credentials file does not exist!`,
      "do-devops/no-credentials-file"
    );
  }
  if (!profile2[profileName]) {
    throw new DevopsError(
      `The AWS profile "${profileName}" does not exist in the AWS credentials file! Valid profile names are: ${Object.keys(
        profile2
      ).join(", ")}`,
      "do-devops/invalid-profile-name"
    );
  }
  return profile2[profileName];
}

// src/shared/aws/getAwsIdentityFromProfile.ts
async function getAwsIdentityFromProfile(profile2) {
  const sts = new STS({
    accessKeyId: profile2.aws_access_key_id,
    secretAccessKey: profile2.aws_secret_access_key
  });
  const result = await sts.getCallerIdentity().promise();
  return {
    userId: result.UserId,
    accountId: result.Account,
    arn: result.Arn,
    user: result.Arn.split(":").pop()
  };
}

// src/shared/aws/getAwsLambdaFunctions.ts
async function getAwsLambdaFunctions(opts) {
  const profile2 = opts.profile ? opts.profile : await determineProfile(opts);
  const region = opts.region ? opts.region : await determineRegion(opts);
  if (!profile2 || !region) {
    throw new DevopsError(
      `Requesting a list of AWS functions requires an AWS profile and a specified region. One or both were missing [ p: ${profile2}, r: ${region}] `,
      "not-ready/missing-aws-properties"
    );
  }
  const credentials = convertProfileToApiCredential(await getAwsProfile(profile2));
  const lambda = new Lambda({ ...credentials, region });
  return lambda.listFunctions().promise();
}

// src/shared/aws/getAwsProfileDictionary.ts
async function getAwsProfileDictionary() {
  try {
    const credentialsFile = hasAwsProfileCredentialsFile();
    if (!credentialsFile) {
      return {};
    }
    const data = await readFile(credentialsFile);
    const targets = ["aws_access_key_id", "aws_secret_access_key", "region"];
    const extractor = (agg, curr) => {
      let profileSection = "unknown";
      for (const lineOfFile of curr) {
        if (lineOfFile.slice(-1) === "]") {
          profileSection = lineOfFile.slice(0, -1);
          agg[profileSection] = {};
        }
        for (const t of targets) {
          if (lineOfFile.includes(t)) {
            const [_, key, value] = lineOfFile.match(/\s*(\S+)\s*=\s*(\S+)/);
            if (key === "region") {
              agg[profileSection][key] = value;
            } else {
              agg[profileSection][key] = value;
            }
          }
        }
      }
      return agg;
    };
    const credentials = data ? data.split("[").map((i) => i.split("\n")).reduce(extractor, {}) : {};
    return credentials;
  } catch {
    return {};
  }
}

// src/shared/aws/hasAwsCredentialsFile.ts
import path18 from "path";
import { existsSync as existsSync4 } from "fs";
import { homedir as homedir4 } from "os";
function hasAwsProfileCredentialsFile() {
  const filePath = path18.join(homedir4(), ".aws/credentials");
  return existsSync4(filePath) ? filePath : false;
}

// src/shared/serverless/askAboutLogForwarding.ts
import chalk30 from "chalk";
import inquirer5 from "inquirer";

// src/shared/serverless/askForFunction.ts
import inquirer6 from "inquirer";

// src/shared/serverless/getLocalServerlessFunctionsFromServerlessYaml.ts
async function getLocalServerlessFunctionsFromServerlessYaml() {
  return serverlessYamlExists() ? (await getServerlessYaml()).functions : {};
}

// src/shared/serverless/askForFunction.ts
async function askForFunction(message = "Which function do you want to use?") {
  const fns = Object.keys(await getLocalServerlessFunctionsFromServerlessYaml() || {});
  const question = {
    type: "list",
    message,
    name: "fn",
    choices: fns
  };
  const answer = await inquirer6.prompt(question);
  return answer.fn;
}

// src/shared/serverless/askForStage.ts
import inquirer7 from "inquirer";
async function askForStage(message = "What stage are you working with?") {
  const question = {
    type: "list",
    name: "stage",
    message,
    default: "dev",
    choices: ["dev", "test", "stage", "prod"]
  };
  const answer = await inquirer7.prompt(question);
  return answer.stage;
}

// src/shared/serverless/findAllHandlerFiles.ts
import { globbySync as sync3 } from "globby";

// src/shared/serverless/findConfigFunctionDefnFiles.ts
import { globbySync as sync4 } from "globby";

// src/shared/serverless/findInlineFunctionDefnFiles.ts
import { globbySync as sync5 } from "globby";

// src/shared/serverless/getServerlessYaml.ts
import fs2 from "fs";
import path19 from "path";
import { load as load2 } from "js-yaml";
async function getServerlessYaml() {
  const baseStructure = {
    functions: {},
    stepFunctions: { stateMachines: {} }
  };
  try {
    const fileContents = fs2.readFileSync(path19.join(process.cwd(), "serverless.yml"), {
      encoding: "utf-8"
    });
    const config = load2(fileContents);
    return { ...baseStructure, ...config };
  } catch (error) {
    const error_ = isDevopsError(error) ? new DevopsError(`Failure getting serverless.yml: ${error.message}`, error.name) : new DevopsError(`Failure getting serverless.yml`, "serverless/not-ready");
    throw error_;
  }
}

// src/shared/serverless/getAccountInfoFromServerlessYaml.ts
async function getAccountInfoFromServerlessYaml() {
  try {
    const config = await getServerlessYaml();
    const info2 = {
      name: typeof config.service === "string" ? config.service : config.service.name,
      accountId: config?.custom?.accountId,
      region: config.provider.region,
      profile: config.provider.profile,
      pluginsInstalled: config.plugins || []
    };
    if (config?.custom?.logForwarding) {
      info2.logForwarding = config.custom.logForwarding.destinationARN;
    }
    return info2;
  } catch (error) {
    throw new DevopsError(
      `Problems getting serverless.yml's account info: ${error.message}`,
      "serverless-framework/account-info"
    );
  }
}

// src/shared/serverless/getAwsProfileFromServerless.ts
import chalk31 from "chalk";

// src/shared/observations/isServerless.ts
import fs3 from "fs";
import path20 from "path";
async function isServerless() {
  const hasServerlessConfig = fs3.existsSync(path20.join(process.cwd(), "serverless.yml"));
  let slsConfig;
  try {
    slsConfig = await getServerlessYaml();
  } catch {
  }
  const pkgJson = getPackageJson();
  const hasAsDevDep = pkgJson ? Object.keys(pkgJson.devDependencies || {}).includes("serverless") : false;
  const isUsingTypescriptMicroserviceTemplate = fs3.existsSync(
    path20.join(process.cwd(), "serverless-config/config.ts")
  );
  const hasProviderSection = slsConfig && slsConfig.provider ? true : false;
  const configIsParsable = hasServerlessConfig && slsConfig ? true : false;
  return hasServerlessConfig || hasAsDevDep || isUsingTypescriptMicroserviceTemplate ? {
    hasServerlessConfig,
    hasAsDevDep,
    isUsingTypescriptMicroserviceTemplate,
    hasProviderSection,
    configIsParsable
  } : false;
}

// src/shared/ast/aboutDefaultExport.ts
import { Project, SymbolFlags, SyntaxKind } from "ts-morph";

// src/shared/ast/astParseWithAcorn.ts
import { parse as parse4 } from "recast";

// src/@types/command.ts
import { isNonNullObject } from "common-types";
function isCommandDescriptor(desc) {
  return isNonNullObject(desc) && desc.short && desc.complete ? true : false;
}
function isDynamicCommandDefinition(defn) {
  return typeof defn === "function";
}
function isDoDevopsCommand(cmd) {
  return typeof cmd === "object" && typeof cmd.handler === "function" && typeof cmd.kind === "string" && cmd.description !== void 0;
}

// src/@types/config-types.ts
function configIsReady(config) {
  return typeof config === "object" && config !== null && config.kind === "integrated" && config.ready || config.kind === "project" && config.projectConfig === true || config.kind === "user" && config.userConfig === true;
}

// src/shared/ast/astParseWithAcorn.ts
import acorn from "recast/parsers/acorn.js";

// src/shared/ast/astParseWithTypescript.ts
import { parse as parse5 } from "recast";
import { readFileSync as readFileSync2 } from "fs";
import parser from "recast/parsers/typescript.js";
function astParseWithTypescript(filename) {
  const fileContents = readFileSync2(filename, {
    encoding: "utf8"
  });
  return filename.includes(".ts") ? parse5(fileContents, {
    parser
  }) : parse5(fileContents);
}

// src/shared/ast/fileHasExports.ts
import { Project as Project2 } from "ts-morph";
function fileHasExports(file) {
  try {
    const p = new Project2();
    p.addSourceFileAtPath(file);
    const source = p.getSourceFileOrThrow(file);
    const assignments = source.getExportAssignments();
    const exp = source.getExportDeclarations();
    const variables = source.getVariableDeclarations().filter((d) => d.hasExportKeyword());
    const functions = source.getFunctions().filter((f) => f.hasExportKeyword());
    const types = source.getTypeAliases().filter((f) => f.isExported());
    const count = assignments.length + variables.length + functions.length + exp.length + types.length;
    return count > 0;
  } catch (error) {
    throw new Error(`Problems checking whether ${file} has exports: ${error.message}`);
  }
}

// src/shared/ast/findHandlerConfig.ts
import chalk32 from "chalk";
function findHandlerConfig(filename, isWebpackZip = false) {
  const ast = astParseWithTypescript(filename);
  const hash = {};
  const config = namedExports(ast).find((i) => i.name === "config");
  if (config) {
    const fn = (filename.split("/").pop() || "").replace(".ts", "");
    for (const i of config.properties || []) {
      hash[i.name] = i.value;
    }
    hash.handler = isWebpackZip ? `.webpack/${fn}.handler` : filename.replace(".ts", ".handler");
    if (isWebpackZip) {
      if (hash.package) {
        console.log(
          chalk32.gray`- the handler function "${fn}" had a defined package config but it will be replaced by a ${chalk32.italic`artifact`} reference`
        );
      }
      hash.package = { artifact: `.webpack/${fn}.zip` };
    }
    return {
      interface: config.interface,
      config: hash
    };
  } else {
    return;
  }
}

// src/shared/ast/getValidServerlessHandlers.ts
import { globbySync as sync6 } from "globby";
import path21 from "path";
import chalk33 from "chalk";
function getValidServerlessHandlers(opts = {}) {
  const allFiles = sync6(path21.join(process.env.PWD || "", "/src/**/*.ts"));
  return allFiles.reduce((agg, curr) => {
    let ast;
    let status = "starting";
    try {
      ast = astParseWithTypescript(curr);
      status = "file-parsed";
      if (!ast.program.body[0].source) {
        if (opts.verbose) {
          console.log(
            chalk33.gray`- the file ${chalk33.blue(toRelativePath(curr))} has no source content; will be ignored`
          );
        }
        return agg;
      }
      const loc = ast.program.body[0].source.loc;
      status = "loc-identified";
      const handler14 = loc.tokens.find((i) => i.value === "handler");
      status = handler14 ? "handler-found" : "handler-missing";
      if (handler14) {
        if (!Array.isArray(agg)) {
          throw new TypeError(
            `Found a handler but somehow the file aggregation is not an array! ${handler14}`
          );
        }
        agg.push(curr);
      }
      return agg;
    } catch (error) {
      console.log(
        `- Error processing  ${chalk33.red(toRelativePath(curr))} [s: ${status}]: ${chalk33.grey(error.message)}`
      );
      return agg;
    }
  }, []);
}

// src/shared/ast/getValidStepFunctions.ts
import { globbySync } from "globby";
import { join as join10 } from "pathe";
import { describe } from "native-dash";
import chalk34 from "chalk";

// src/shared/ast/isTypeBasedObject.ts
import { isNonNullObject as isNonNullObject2 } from "common-types";

// src/shared/ast/namedExports.ts
import { get } from "native-dash";
function getSpread(node) {
  return get(node, "argument.name");
}
function getValue(node) {
  switch (node.type) {
    case "Literal":
    case "StringLiteral":
    case "NumericLiteral":
    case "BooleanLiteral":
      return get(node, "value");
    case "TemplateLiteral":
      return get(node, "quasis.0.value.cooked");
    case "ObjectExpression":
      return get(node, "properties", []).reduce((agg, i) => {
        agg[get(i, "key.name")] = getValue(get(i, "value"));
        return agg;
      }, {});
    case "ArrayExpression":
      return get(node, "elements", []).map((i) => getValue(i));
    case "SpreadElement":
      return getSpread(node);
    default:
      console.log("unknown type:", node.type);
      write2(`unhandled-node-${node.type}.json`, node, { offsetIfExists: true });
  }
}
function getVariableDeclaration(declaration) {
  const root = get(declaration, "declarations.0");
  const type = get(root, "init.type");
  const properties = get(root, "init.properties", []).map((i) => ({
    name: get(i, "key.name"),
    value: getValue(get(i, "value")),
    type: get(i, "value.type")
  }));
  const params = get(root, "init.params", []).map((i) => get(i, "name", ""));
  return {
    name: get(root, "id.name"),
    interface: get(root, "id.typeAnnotation.typeAnnotation.typeName.name"),
    type,
    ...properties ? { properties } : {},
    ...params.length > 0 ? { params } : {}
  };
}
function getInterfaceDeclaration(declaration) {
  return {
    name: get(declaration, "id.name")
  };
}
function namedExports(file) {
  const ast = typeof file === "string" ? astParseWithTypescript(file) : file;
  const namedExports3 = ast.program.body.filter((i) => i.type === "ExportNamedDeclaration");
  const output = [];
  for (const i of namedExports3) {
    const type = get(i, "declaration.type");
    output.push({
      type,
      kind: get(i, "declaration.kind") || type === "TSTypeAliasDeclaration" ? "type" : type === "TSInterfaceDeclaration" ? "interface" : "",
      interface: get(
        i,
        "declaration.declarations.0.id.typeAnnotation.typeAnnotation.typeName.name",
        null
      ),
      comments: get(i, "comments", []),
      ...type === "VariableDeclaration" ? getVariableDeclaration(get(i, "declaration")) : type === "TSInterfaceDeclaration" ? getInterfaceDeclaration(get(i, "declaration")) : { name: "" }
    });
  }
  return output;
}

// src/shared/serverless/getLocalHandlerInfo.ts
import path22 from "path";
import { get as get2 } from "native-dash";
var _cache;
async function getLocalHandlerInfo(breakCache = false) {
  if (_cache && !breakCache) {
    return _cache;
  }
  const sourcePaths = getValidServerlessHandlers();
  const convertToWebpackPath = (source) => path22.join(process.cwd(), ".webpack", (source.split("/").pop() || "").replace(".ts", ".js"));
  const webpackPaths = sourcePaths.map((i) => convertToWebpackPath(i));
  const sourceInfo = await fileInfo(...sourcePaths);
  const webpackFilesExist = filesExist(...webpackPaths);
  const webpackInfo = webpackFilesExist ? await fileInfo(...webpackFilesExist) : [];
  return sourceInfo.reduce((agg, source) => {
    return {
      ...agg,
      fn: source.filename,
      source: source.filepath,
      sourceModified: source.mtime,
      webpack: convertToWebpackPath(source.filepath),
      webpackModified: get2(
        webpackInfo.find((w2) => w2.filename === source.filename) || {},
        "stats.mtime",
        new Date("1970-01-01")
      )
    };
  }, []);
}

// src/shared/serverless/getMicroserviceConfig.ts
import chalk35 from "chalk";
import { asyncExec as asyncExec2 } from "async-shelljs";

// src/shared/serverless/getServerlessBuildConfiguration.ts
import { TypedMapper } from "typed-mapper";

// src/shared/yeoman/getYeomanConfig.ts
import chalk36 from "chalk";
import { existsSync as existsSync5, readFileSync as readFileSync3 } from "fs";
import parse6 from "destr";
import path23 from "path";
function getYeomanConfig(scaffold = "generator-lambda-typescript") {
  const yoFile = path23.posix.join(process.cwd(), ".yo-rc.json");
  const transientFile = path23.posix.join(process.cwd(), ".yo-transient.json");
  const hasYo = existsSync5(yoFile);
  const hasTransient = existsSync5(transientFile);
  let yo = {};
  let transient = {};
  if (hasYo) {
    try {
      yo = parse6(readFileSync3(yoFile, "utf8"))[scaffold];
    } catch {
      console.log(
        `- there appears to ${chalk36.italic`be`} a yeoman config file but it could not be parsed ${"\u{1F4A9}" /* poop */}`
      );
      console.log(
        chalk36.gray`- Note: we are looking for the "${scaffold}" as a root property, other yeoman scaffolding not considered`
      );
    }
  }
  if (hasTransient) {
    try {
      transient = parse6(readFileSync3(transientFile, "utf8"));
    } catch {
      console.log(
        `- there appears to be a ${chalk36.italic`transient`} yeoman config file -- ${chalk36.blue`.yo-transient.json`} -- but it could not be parsed ${"\u{1F4A9}" /* poop */}`
      );
    }
  }
  return { ...transient, ...yo };
}

// src/shared/yeoman/getYeomanScaffolds.ts
import { existsSync as existsSync6, readFileSync as readFileSync4 } from "fs";
import parse7 from "destr";
import path24 from "path";
function getYeomanScaffolds() {
  const yoFile = path24.posix.join(process.cwd(), ".yo-rc.json");
  const hasYo = existsSync6(yoFile);
  if (!hasYo) {
    return [];
  }
  return Object.keys(parse7(readFileSync4(yoFile, "utf-8")));
}

// src/shared/serverless/getServerlessBuildConfiguration.ts
function transformYeomanFormat(input) {
  return TypedMapper.map({
    name: "serviceName",
    accountId: "awsAccount",
    profile: "awsProfile",
    region: "awsRegion",
    devDependencies: () => [],
    pluginsInstalled: () => []
  }).convertObject(input);
}
async function getServerlessBuildConfiguration() {
  const modern = getYeomanScaffolds().includes("generator-lambda-typescript");
  const pkg = getPackageJson();
  if (!pkg) {
    throw new DevopsError(
      `Attempt to build Serverless configuration failed as there is no package.json the current working directory!`,
      "not-ready/missing-package-json"
    );
  }
  const knownAccountInfo = {
    ...modern ? transformYeomanFormat(getYeomanConfig()) : await getAccountInfoFromServerlessYaml(),
    devDependencies: Object.keys(pkg.devDependencies || {}),
    pluginsInstalled: Object.keys(pkg.devDependencies || {}).filter(
      (i) => i.startsWith("serverless-")
    )
  };
  const accountInfo = await askForAccountInfo(knownAccountInfo);
  return accountInfo;
}

// src/shared/serverless/sandbox.ts
import { asyncExec as asyncExec3 } from "async-shelljs";

// src/shared/git/convertGitUrlToHttp.ts
function convertGitUrlToHttp(gitUrl) {
  return gitUrl.replace(/git(\+(ssh|https)){0,1}:\/\/(git@){0,1}/, "https://").replace(/\.git$/, "");
}

// src/shared/git/git.ts
import simpleGit from "simple-git";
function git(dir, options15 = {}) {
  if (!dir) {
    dir = currentDirectory();
  }
  return simpleGit(dir, options15);
}

// src/shared/git/getGitBranch.ts
async function getCurrentGitBranch(baseDir) {
  baseDir = baseDir ? baseDir : process.cwd();
  const g = git(baseDir);
  const branch = await g.branch();
  return branch.current;
}

// src/shared/git/getGitLastCommit.ts
async function getGitLastCommit() {
  const latest = (await git().log({ maxCount: 1, strictDate: true })).latest;
  return latest;
}

// src/shared/git/getGitRemote.ts
async function getGitRemotes(baseDir) {
  try {
    baseDir = baseDir ? baseDir : process.cwd();
    const g = git(baseDir);
    const remotes = await g.getRemotes(true);
    return remotes.length > 0 ? remotes : [];
  } catch {
    return [];
  }
}

// src/shared/serverless/saveToServerlessYaml.ts
import chalk37 from "chalk";
import fs4 from "fs";
import path25 from "path";
import { dump as dump2 } from "js-yaml";
async function saveToServerlessYaml(data) {
  try {
    const filename = path25.join(process.cwd(), "serverless.yml");
    console.log({ filename, data });
    const yamlData = dump2(data);
    fs4.writeFileSync(filename, yamlData, { encoding: "utf8" });
  } catch (error) {
    console.log(`- {red writing the {bold serverless.yml} file has failed!} ${"\u{1F4A9}" /* poop */}`);
    if (isDevopsError(error)) {
      console.log(error.message);
      console.log(chalk37.dim`${error.stack}`);
      process.exit();
    }
  }
}

// src/shared/serverless/serverlessYamlExists.ts
import { existsSync as existsSync7 } from "fs";
import path26 from "path";
function serverlessYamlExists() {
  return existsSync7(path26.posix.join(process.cwd(), "serverless.yml"));
}

// src/shared/serverless/accountInfo/askForAccountInfo.ts
import { AWS_REGIONS } from "common-types";
import inquirer8 from "inquirer";
import chalk38 from "chalk";
async function askForAccountInfo(config = {}) {
  const pkgJson = getPackageJson();
  const profiles = await getAwsProfileDictionary();
  if (config.profile && config.name && config.accountId && config.region && config.pluginsInstalled && (config.logForwarding || pkgJson && !Object.keys(pkgJson.devDependencies || {}).includes("serverless-log-forwarding"))) {
    return config;
  }
  const baseProfileQuestion = {
    name: "profile",
    message: "Choose a profile from your AWS credentials file",
    default: config.profile,
    when: () => !config.profile
  };
  const profileQuestion = profiles ? {
    ...baseProfileQuestion,
    type: "list",
    choices: Object.keys(profiles)
  } : { ...baseProfileQuestion, type: "input" };
  let questions = [
    {
      type: "input",
      name: "name",
      message: "What is the Service Name for this repo?",
      default: config.name || pkgJson ? pkgJson.name : void 0,
      when: () => !config.name
    },
    profileQuestion
  ];
  let answers2 = await inquirer8.prompt(questions);
  const merged = {
    ...config,
    ...answers2
  };
  if (merged.profile && !userHasAwsProfile(merged.profile)) {
    console.log(
      `- you are deploying with the {green ${merged.profile} AWS profile but you do not have this defined yet! ${"\u{1F621}" /* angry */}`
    );
    console.log(chalk38.grey`- AWS profiles must be added in ${chalk38.blue`src/.aws/credentials`}`);
    console.log(
      chalk38.grey`- if you want to override the default behavior you can state a different profile with the ${chalk38.blue`--profile`} tag`
    );
    process.exit();
  }
  if (!merged.profile) {
    console.log(`- you have not provided an AWS {bold profile}; exiting ...`);
    process.exit();
  }
  if (!await userHasAwsProfile(merged.profile)) {
    console.log(
      `- you do {bold NOT} have the credentials for the profile ${chalk38.blue(merged.profile)}! Please add this before
  trying again. ${"\u{1F621}" /* angry */}
`
    );
    console.log(chalk38.grey`- the credentials file is located at ${chalk38.blue`src/.aws/credentials`}\n`);
    process.exit();
  }
  const awsProfile = await getAwsProfile(merged.profile);
  if (merged.region) {
    config.region = awsProfile.region;
  }
  if (!merged.accountId) {
    console.log(`- looking up the Account ID for the given profile`);
    try {
      merged.accountId = (await getAwsIdentityFromProfile(awsProfile)).accountId;
    } catch {
    }
  }
  questions = [
    {
      type: "input",
      name: "accountId",
      message: "what is the Amazon Account ID which you are deploying to?",
      when: () => !merged.accountId
    },
    {
      type: "list",
      name: "region",
      message: "what is the region you will be deploying to?",
      choices: AWS_REGIONS,
      default: merged.region || awsProfile.region || "us-east-1",
      when: () => !config.region
    }
  ];
  let plugins;
  try {
    const sls = await getServerlessYaml();
    plugins = { pluginsInstalled: sls.plugins || [] };
  } catch {
    plugins = { pluginsInstalled: [] };
  }
  answers2 = {
    ...plugins,
    ...answers2,
    ...await inquirer8.prompt(questions)
  };
  return merged;
}

// src/shared/serverless/build/buildLambdaTypescriptProject.ts
import chalk39 from "chalk";
import * as os from "os";
import { asyncExec as asyncExec4, rm } from "async-shelljs";
var ACCOUNT_INFO_YAML = "./serverless-config/account-info.yml";
async function buildLambdaTypescriptProject(opts = {}, _config = {}, configFn) {
  const modern = getYeomanScaffolds().includes("generator-lambda-typescript");
  const accountInfo = await getServerlessBuildConfiguration();
  const hasWebpackPlugin = accountInfo?.devDependencies?.includes("serverless-webpack");
  if (opts.force) {
  }
  if (!modern) {
    saveYamlFile(ACCOUNT_INFO_YAML, accountInfo);
  }
  console.log(
    `- The account info for ${chalk39.bold`${accountInfo.name} [`} ${chalk39.dim(accountInfo.accountId)} ${chalk39.bold`]`} has been gathered`
  );
  const handlerInfo = await getLocalHandlerInfo();
  console.log(
    chalk39.gray`- handler functions [ ${chalk39.bold(String(handlerInfo.length))} ] have been identified`
  );
  await createInlineExports(handlerInfo);
  console.log(
    chalk39.gray`- The inline function configuration file [ ${chalk39.bold.italic`serverless-config/functions/inline.ts`} ] has been configured`
  );
  await createFunctionEnum(handlerInfo);
  console.log(
    chalk39.gray`- The enumeration and type [ ${chalk39.bold.italic`src/@types/functions.ts`} ] for the available functions has been configured `
  );
  if (hasWebpackPlugin) {
    const exist = filesExist("webpack.js-entry-points.json", "webpack.js-entry-points.json");
    if (exist) {
      rm(...exist);
      console.log(
        `- ${"\u{1F440}" /* eyeballs */} removed webpack entry point files so as not to confuse with what the ${chalk39.italic`serverless-webpack`} plugin is doing}`
      );
    }
  } else {
    await createWebpackEntryDictionaries(handlerInfo.map((i) => i.source));
    console.log(
      chalk39.gray`- added webpack ${chalk39.italic`entry files`} to facilitate code build and watch operations`
    );
  }
  if (modern && configFn) {
    const serverless = configFn(accountInfo);
    await saveToServerlessYaml(serverless);
  } else {
    console.log(
      `- handing off the build of the ${chalk39.green.bold`serverless.yml`} to the repo's ${chalk39.bold`build`} script
`
    );
    await asyncExec4("yarn ts-node serverless-config/build.ts --color=always", {
      env: {
        ...process.env,
        TERM: "xterm-color",
        ...os.platform().includes("win") ? {} : { shell: "/bin/bash" }
      }
    });
    rm(ACCOUNT_INFO_YAML);
    console.log(chalk39.gray`- removed the temporary ${chalk39.blue`account-info.yml`} file from the repo`);
  }
  console.log(
    chalk39.green`- ${chalk39.bold`serverless.yml`} has been updated successfully ${"\u{1F680}" /* rocket */}\n`
  );
}

// src/shared/serverless/build/clearOldFiles.ts
import { rm as rm2 } from "async-shelljs";

// src/shared/serverless/build/createFunctionEnum.ts
import path27 from "path";
import { existsSync as existsSync8, mkdirSync as mkdirSync2, writeFile as writeFile2 } from "fs";
import { promisify as promisify4 } from "util";
import chalk40 from "chalk";
var write3 = promisify4(writeFile2);
async function createFunctionEnum(handlers) {
  const header = `export enum AvailableFunction {
`;
  const footer = `
}
  
export type IAvailableFunction = keyof typeof AvailableFunction;
`;
  const body = [];
  for (const handler14 of handlers) {
    const config = findHandlerConfig(handler14.source);
    if (config) {
      const fn = handler14.fn;
      const comment = config.config.description ?? `${fn} handler`;
      body.push(
        `
  /**
   * ${comment}
   **/
  ${fn} = "${fn}"`
      );
    } else {
      console.log(
        `- ${"\u{1F621}" /* angry */} also excluding the ${chalk40.italic(handler14.source.split("/").pop())} in the generated enumeration of handlers`
      );
    }
  }
  const fileText = `${header}${body.join(",")}${footer}`;
  if (!existsSync8(path27.join(process.cwd(), "/src/@types"))) {
    mkdirSync2(path27.join(process.cwd(), "/src/@types"));
  }
  await write3(path27.resolve(path27.join(process.cwd(), "/src/@types/functions.ts")), fileText, {
    encoding: "utf8"
  });
  return fileText;
}

// src/shared/serverless/build/createInlineExports.ts
import chalk41 from "chalk";
import path28 from "path";
import { writeFileSync as writeFileSync4 } from "fs";
import { isServerlessFunctionHandler } from "common-types";
function objectPrint(obj) {
  const contents = [];
  for (const key of Object.keys(obj)) {
    let value = obj[key];
    if (typeof value === "string") {
      value = `"${value.replace(/"/g, '\\"')}"`;
    }
    if (typeof value === "object") {
      value = JSON.stringify(value);
    }
    contents.push(`  ${key}: ${value}`);
    contents.join(",\n	");
    continue;
  }
  return contents;
}
function warnAboutMissingTyping(config) {
  const incorrectOrMissingTyping = config.filter((i) => i.interface !== "IHandlerConfig");
  if (incorrectOrMissingTyping.length > 0) {
    console.log(
      `- there were ${String(
        incorrectOrMissingTyping.length
      )} handler functions who defined a ${chalk41.italic`config`} but did not type it as {bold IHandlerConfig}`
    );
    console.log(
      chalk41.gray`- the function configs needing attention are: ${chalk41.italic(incorrectOrMissingTyping.map((i) => isServerlessFunctionHandler(i.config) ? i.config.handler : i.config.image).join(", "))}`
    );
  }
}
async function createInlineExports(handlers) {
  const header = 'import { IServerlessFunction } from "common-types";\n';
  const body = [];
  const config = [];
  for (const handler14 of handlers) {
    const handlerConfig = findHandlerConfig(handler14.source, false);
    if (handlerConfig && handlerConfig.interface) {
      config.push(handlerConfig);
    } else {
      console.log(
        `- ${"\u{1F4A9}" /* poop */} the {red ${toRelativePath(
          handler14.source
        )}} file will be ignored as a handler as it has no CONFIG section defined. This is probably a mistake!`
      );
    }
  }
  const exportSymbols = [];
  warnAboutMissingTyping(config);
  for (const handler14 of config) {
    if (isServerlessFunctionHandler(handler14.config)) {
      const fnName = (handler14?.config?.handler.split("/").pop() || "").replace(/\.[^.]+$/, "");
      exportSymbols.push(fnName);
      const symbol = `const ${fnName}: IServerlessFunction = { 
  ${objectPrint(handler14.config)}
  }
  `;
      body.push(symbol);
    } else {
      console.warn(
        `[${handler14.config.image}]: the serverless function passed into createInlineExports appears to define an "image" rather than a "handler". This should be investigated!`
      );
    }
  }
  const file = `
${header}
${body.join("\n")}

export default {
  ${exportSymbols.join(",\n	")}
}`;
  writeFileSync4(path28.join(process.env.PWD || "", "serverless-config/functions/inline.ts"), file, {
    encoding: "utf8"
  });
}

// src/shared/serverless/build/createWebpackEntryDictionaries.ts
import path29 from "path";
function useKey(key) {
  return (agg, curr) => {
    agg[curr.fn] = curr[key];
    return agg;
  };
}
async function createWebpackEntryDictionaries(handlerFns) {
  const data = handlerFns.reduce((agg, f) => {
    const fn = (f.split("/").pop() || "").replace(".ts", "");
    const tsPath = "./" + path29.relative(process.cwd(), f);
    const jsPath = (tsPath.split("/").pop() || "").replace(/(.*)/, ".webpack/$1").replace(".ts", ".js");
    return [...agg, { fn, tsPath, jsPath }];
  }, []);
  await Promise.all([
    write2("webpack.ts-entry-points.json", data.reduce(useKey("tsPath"), {})),
    write2("webpack.js-entry-points.json", data.reduce(useKey("jsPath"), {}))
  ]);
}

// src/shared/serverless/build/saveFunctionsTypeDefinition.ts
import chalk42 from "chalk";

// src/shared/serverless/build/writeInlineFunctions.ts
import * as fs5 from "fs";
import { promisify as promisify5 } from "util";
var writeFile4 = promisify5(fs5.writeFile);

// src/shared/serverless/build/zipWebpackFiles.ts
import chalk43 from "chalk";
import zip from "bestzip";

// src/shared/serverless/layers/getLayersWithMeta.ts
import { join as join11 } from "pathe";
import { cwd as cwd2 } from "process";
import { readFileSync as readFileSync5 } from "fs";
function getLayersFromPackageJson() {
  const pkg = getPackageJson();
  if (!pkg) {
    throw new DevopsError(
      `Attempt to read layers from package.json but file is missing!`,
      "not-ready/missing-package-json"
    );
  }
  const devDeps = Object.keys(pkg.devDependencies || {});
  const pkgJsonFiles = devDeps.filter((d) => {
    const foreignPkg = getPackageJson(join11(process.cwd(), "node_modules", d));
    if (!foreignPkg) {
      throw new DevopsError(
        `Attempt to get info on package info on "" requires that it be installed in the repo. Make sure to install deps before running this command.`,
        "not-ready/missing-dep"
      );
    }
    const keywords = foreignPkg.keywords;
    return keywords ? keywords.includes("aws-layer-meta") || keywords.includes("aws-layer") : false;
  });
  return pkgJsonFiles.filter(Boolean).reduce((agg, d) => {
    const file = join11(cwd2(), "node_modules", d);
    const meta = JSON.parse(readFileSync5(file, "utf8"));
    const info2 = meta ? { ...meta, name: meta.name } : { name: d, namespace: "unknown", versions: [] };
    agg.push(info2);
    return agg;
  }, []);
}

// src/shared/observations/determineProfile.ts
var profile;
async function determineProfile(opts, observations = /* @__PURE__ */ new Set()) {
  if (opts.profile) {
    return opts.profile;
  }
  if (observations.has("serverlessTs")) {
  }
  if (observations.has("serverlessYml")) {
    const serverlessYaml = await getServerlessYaml();
    if (serverlessYaml.provider.profile) {
      return serverlessYaml.provider.profile;
    }
  } else {
  }
  let doConfig;
  try {
    doConfig = getIntegratedConfig();
    if (configIsReady(doConfig) && doConfig.aws?.defaultProfile) {
      profile = doConfig.aws?.defaultProfile;
    }
  } catch {
  }
  if (!profile && opts.interactive) {
    try {
      profile = await askForAwsProfile({ exitOnError: false });
    } catch {
    }
  }
  if (profile) {
    saveProjectConfig({ aws: { defaultProfile: profile } });
  }
  return profile ? profile : false;
}

// src/shared/observations/determineLinter.ts
import parse8 from "destr";
function determineLinter() {
  const observations = /* @__PURE__ */ new Set();
  let eslint = false;
  let tslint = false;
  let prettier = false;
  const pkg = getPackageJson();
  if (pkg) {
    if (hasDevDependency("eslint")) {
      observations.add("eslint");
      if (hasDevDependency("@typescript-eslint/eslint-plugin")) {
        observations.add("typescriptEslintPlugin");
      }
      if (hasDevDependency("@typescript-eslint/parser")) {
        observations.add("typescriptEslintParser");
      }
      if (pkg.eslintConfig) {
        observations.add("eslintConfig");
        eslint = { config: parse8(pkg.eslintConfig), filename: "package.json" };
      } else {
        for (const filename of [".eslintrc", ".eslintrc.js", ".eslintrc.ts"]) {
          const fileContent = readFile(filename);
          eslint = { config: parse8(fileContent), filename };
        }
      }
    }
    if (hasDevDependency("tslint")) {
      observations.add("tslint");
      const fileContent = readFile("tslint.json");
      tslint = fileContent ? { config: parse8(fileContent), filename: "tslint.json" } : true;
    }
    if (hasDevDependency("prettier")) {
      observations.add("prettier");
      if (fileExists(".prettierrc")) {
        prettier = readFile(".prettierrc") || false;
      }
    }
    if (hasDevDependency("eslint-prettier-plugin")) {
      observations.add("eslintPrettierPlugin");
    }
  }
  return { observations, eslint, tslint, prettier };
}

// src/shared/observations/determinePackageManager.ts
import chalk44 from "chalk";
async function determinePackageManager(opts, observations) {
  if (!observations.has("packageJson")) {
    throw new DevopsError(
      `Can not determine the default package manager in a directory that has no package.json file!`,
      "not-ready/missing-package-json"
    );
  }
  if (observations.has("packageManagerConflict")) {
    console.log(
      `- ${"\u26A0\uFE0F" /* warn */}} there are indications of ${chalk44.italic`more`} than one package manager being used!`
    );
    const pkgManager = await askListQuestion(
      "Which package manager do you expect to use in this repo?",
      ["npm", "pnpm", "yarn"],
      {
        default: observations.has("pnpm") ? "pnpm" : observations.has("yarn") ? "yarn" : "npm"
      }
    );
    await saveProjectConfig({ general: { pkgManager } });
    const removed = await removeOtherLockFiles(pkgManager);
    if (removed.length > 0) {
      console.log(`- removed `);
    }
  }
  const userConfig = getUserConfig();
  if (observations.has("yarn")) {
    return "yarn";
  }
  if (observations.has("npm")) {
    return "npm";
  }
  if (observations.has("pnpm")) {
    return "pnpm";
  }
  if (userConfig.general?.pkgManager) {
    return userConfig.general?.pkgManager;
  }
  const config = getProjectConfig();
  if (config.general?.pkgManager) {
    return config.general.pkgManager;
  }
  if (opts.interactive) {
    const manager = await askListQuestion(
      "We couldn't determine the package manager to use, would you like to add a default pkg manager to your user profile?",
      ["npm", "pnpm", "yarn", "no thanks"],
      { default: "pnpm" }
    );
    if (manager === "no thanks") {
    } else {
      await saveUserConfig({ general: { pkgManager: manager } });
      return manager;
    }
  }
  return false;
}

// src/shared/observations/determineRegion.ts
import chalk45 from "chalk";
import { get as get3 } from "native-dash";
async function determineRegion(opts = {}, observations = /* @__PURE__ */ new Set()) {
  const config = getIntegratedConfig();
  let region = opts.region || process.env.AWS_REGION;
  if (!region && observations.has("serverlessYml")) {
    try {
      region = get3(await getServerlessYaml(), "provider.region", void 0);
    } catch {
    }
  }
  if (!region) {
    region = get3(config, "global.defaultAwsRegion", void 0);
  }
  if (!region) {
    const profileName = await determineProfile(opts || {});
    if (profileName) {
      const profile2 = await getAwsProfile(profileName);
      if (profile2 && profile2.region) {
        region = profile2.region;
      }
    }
  }
  if (!region) {
    const userConfig = getUserConfig();
    if (configIsReady(userConfig) && userConfig.aws?.defaultRegion) {
      if (!opts.quiet) {
        console.log(
          `${chalk45.bold`- AWS region has been resolved using the User's config ${"\u{1F440}" /* eyeballs */}`}. This is the source of "last resort" but may be intended.`
        );
      }
      region = userConfig.aws.defaultRegion;
    }
  }
  return region;
}

// src/shared/observations/determineStackName.ts
import chalk46 from "chalk";

// src/shared/observations/determineStage.ts
import chalk47 from "chalk";
import * as process4 from "process";
import { get as get4 } from "native-dash";
async function determineStage(opts, _observations = /* @__PURE__ */ new Set()) {
  try {
    let stage = get4(opts, "stage") || process4.env.NODE_ENV || process4.env.AWS_STAGE;
    if (!stage) {
      try {
        stage = get4(await getServerlessYaml(), "provider.stage");
      } catch {
      }
    }
    if (opts.interactive) {
      stage = await askForStage();
    }
    return stage;
  } catch (error) {
    console.log(`- attempts to get the desired "stage" have failed! ${"\u{1F4A9}" /* poop */}`);
    console.log(`- {red ${error.message}}`);
    console.log(chalk47.dim`${error.stack}`);
    console.log();
    process4.exit();
  }
}

// src/shared/observations/determineTestFramework.ts
import chalk55 from "chalk";

// src/shared/install/installBuildSystem.ts
import chalk48 from "chalk";

// src/shared/install/installEsLint.ts
import chalk49 from "chalk";
async function installEsLint(opts, observations) {
  const log = logger(opts);
  const proceed = opts.silent ?? await askConfirmQuestion(`Would you like to install and configure ${chalk49.blue`eslint`}?`);
  if (!proceed) {
    return false;
  }
  const success = await installDevDep(
    opts,
    observations,
    "eslint",
    "prettier",
    "@typescript-eslint/eslint-plugin",
    "@typescript-eslint/parser",
    "eslint-config-prettier",
    "eslint-plugin-import",
    "eslint-plugin-prettier",
    "eslint-plugin-promise",
    "eslint-plugin-unicorn"
  );
  if (!success) {
    log.shout(`- ${"\u{1F4A9}" /* poop */} there was a problem installing the eslint dev dependencies`);
    return false;
  }
  log.whisper(
    chalk49.gray` - all ${chalk49.italic`eslint`} and ${chalk49.italic`prettier`} dependencies have been installed`
  );
  await templateFileCopy("eslint/.eslintrc", "/.eslintrc");
  await templateFileCopy("eslint/.prettierrc.js", "/.prettierrc.js");
  log.whisper(
    chalk49.gray` - configuration files for both ${chalk49.italic`eslint`} and ${chalk49.italic`prettier`} have been saved`
  );
  log.info(`- ${"\u{1F389}" /* party */} ${chalk49.blue`eslint`} has been installed and configured
`);
  return true;
}

// src/shared/install/installGit.ts
import chalk50 from "chalk";
async function installGit(opts) {
  const log = logger(opts);
  let setupRemote = false;
  let remoteName = "origin";
  let remoteUrl = "";
  if (!opts.silent) {
    const confirm = await askConfirmQuestion(`Should we initialize ${chalk50.blue`git`} for you?`);
    setupRemote = await askConfirmQuestion(
      `Would you like to set a ${chalk50.italic`remote`} for this repo now?`
    );
    if (setupRemote) {
      remoteName = await askInputQuestion("What should the remote's name be?", {
        default: remoteName
      });
      remoteUrl = await askInputQuestion("What is the URL for remote?");
    }
    if (!confirm) {
      return;
    }
  }
  const g = git();
  await g.init();
  log.info(chalk50.gray` - initialized ${chalk50.blue`git`}`);
  if (setupRemote) {
    await g.addRemote(remoteName, remoteUrl);
    log.info(chalk50.gray` - ${chalk50.blue(remoteName)} remote setup`);
  }
  await installGitIgnore({ ...opts, silent: true });
}

// src/shared/install/installGitIgnore.ts
import chalk51 from "chalk";
async function installGitIgnore(opts) {
  const log = logger(opts);
  if (!opts.silent) {
    const confirm = await askConfirmQuestion("Would you like us to add the file for you?");
    if (!confirm) {
      return;
    }
  }
  const copied = await templateFileCopy("git/.gitignore", ".gitignore");
  if (copied) {
    log.info(chalk51.gray` - created a ${chalk51.blue(".gitignore")} file in the root directory`);
  }
}

// src/shared/install/installPackageManager.ts
import chalk52 from "chalk";

// src/shared/install/installTestFramework.ts
import chalk53 from "chalk";
async function installTestFramework(framework, opts, observations) {
  const log = logger(observations);
  let installed;
  switch (framework) {
    case "uvu": {
      installed = await installDevDep(opts, observations, "uvu", "ts-node");
      break;
    }
    case "jest": {
      installed = await installDevDep(
        opts,
        observations,
        "jest",
        "ts-jest",
        "@types/jest",
        "jest-extended"
      );
      break;
    }
    case "mocha": {
      installed = await installDevDep(
        opts,
        observations,
        "mocha",
        "chai",
        "@types/mocha",
        "@types/chai",
        "ts-node"
      );
      break;
    }
    case "jasmine": {
      installed = await installDevDep(opts, observations, "jasmine");
      break;
    }
    case "qunit": {
      installed = await installDevDep(opts, observations, "qunit");
      break;
    }
    case "ava": {
      installed = await installDevDep(opts, observations, "ava");
      break;
    }
    default: {
      throw new DevopsError(
        `Unknown test framework: ${framework}`,
        "install/unknown-test-framework"
      );
    }
  }
  if (installed) {
    log.whisper(
      chalk53.gray` - installed all ${chalk53.italic`dev dependencies`} for ${chalk53.bold.green(framework)}`
    );
  }
  return installed;
}

// src/shared/install/installTypescript.ts
import chalk54 from "chalk";
async function installTypescript(opts, observations) {
  const log = logger(opts);
  const proceed = opts.silent ?? await askConfirmQuestion(`Would you like to install and configure ${chalk54.blue`typescript`}?`);
  if (!proceed) {
    return false;
  }
  const success = await installDevDep(
    opts,
    observations,
    "typescript",
    "esno",
    "ts-node",
    "@types/node@14"
  );
  if (!success) {
    log.shout(`- ${"\u{1F4A9}" /* poop */} there was a problem installing the Typescript dev dependencies`);
    return false;
  }
  log.whisper(chalk54.gray` - all ${chalk54.italic`typescript`} dependencies have been installed`);
  await templateDirCopy("typescript", "/");
  log.whisper(chalk54.gray` - tsconfig file saved to root`);
  log.info(`- ${"\u{1F389}" /* party */} ${chalk54.blue`typescript`} has been installed and configured
`);
  return true;
}

// src/shared/observations/getObservations.ts
import { existsSync as existsSync9 } from "fs";
function getObservations() {
  let observations = /* @__PURE__ */ new Set();
  const projectConfig = getProjectConfig();
  let pkgJson;
  try {
    pkgJson = getPackageJson();
  } catch {
  }
  if (existsSync9(currentDirectory("Cargo.toml"))) {
    observations.add("cargo");
  }
  if (pkgJson) {
    observations.add("packageJson");
    if (fileExists(currentDirectory(".gitignore"))) {
      observations.add("gitignore");
    }
    if (dirExists(currentDirectory(".git"))) {
      observations.add("git-init");
    }
    if (hasDevDependency("typescript")) {
      observations.add("typescript");
    }
    if (hasDevDependency("typescript-transform-paths")) {
      observations.add("typescriptTransformPaths");
    }
    if (hasDevDependency("rollup")) {
      observations.add("rollup");
    }
    if (hasDevDependency("webpack")) {
      observations.add("webpack");
    }
    if (hasDevDependency("vite")) {
      observations.add("vite");
    }
    if (hasDevDependency("vue")) {
      observations.add("vue");
    }
    if (hasDevDependency("esbuild")) {
      observations.add("esbuild");
    }
    if (hasDependency("firebase-admin") || hasDependency("@firebase/app")) {
      observations.add("firebase");
    }
    if (hasDependency("firemodel")) {
      observations.add("firemodel");
    }
    if (hasDependency("universal-fire")) {
      observations.add("universalFire");
    }
    if (hasDependency("supabase")) {
      observations.add("supabase");
    }
    if (hasDevDependency("mocha")) {
      observations.add("mocha");
    }
    if (hasDevDependency("jest")) {
      observations.add("jest");
    }
    if (hasDevDependency("uvu")) {
      observations.add("uvu");
    }
    if (hasDevDependency("serverless")) {
      observations.add("serverlessFramework");
    }
    if (fileExists("./serverless.yml")) {
      observations.add("serverlessYml");
    }
    if (fileExists("./serverless.ts")) {
      observations.add("serverlessTs");
    }
    if (hasDevDependency("webpack-plugin")) {
      observations.add("serverlessWebpackPlugin");
    }
    if (hasDevDependency("serverless-sam")) {
      observations.add("serverlessSamPlugin");
    }
    if (hasDevDependency("ts-node")) {
      observations.add("tsNode");
    }
    if (fileExists(IMAGE_CACHE)) {
      observations.add("image-cache");
    }
    if (fileExists(TS_IMAGE_SUPPORT_FILE)) {
      observations.add("image-ts-support");
    }
    if (projectConfig.image && projectConfig.image.rules.length > 0) {
      observations.add("image-rules-defined");
    }
    let pm = 0;
    if (fileExists(PKG_MGR_LOCK_FILE_LOOKUP.yarn)) {
      pm++;
      observations.add("yarn");
    }
    if (fileExists(PKG_MGR_LOCK_FILE_LOOKUP.pnpm)) {
      pm++;
      observations.add("pnpm");
      if (fileExists("pnpm-workspace.yaml")) {
        observations.add("monorepo");
        observations.add("pnpmWorkspaces");
      }
    }
    if (fileExists(PKG_MGR_LOCK_FILE_LOOKUP.npm)) {
      pm++;
      observations.add("npm");
    }
    if (pm > 1) {
      observations.add("packageManagerConflict");
    }
    if (hasDevDependency("lerna")) {
      observations.add("lerna");
      observations.add("monorepo");
    }
    if (pkgJson.private === true) {
      observations.add("private");
    }
    if (pkgJson.private === false) {
      observations.add("public");
    }
    if (!observations.has("git-init")) {
      try {
        const parent = getPackageJson(repoDirectory());
        if (parent?.private === true) {
          observations.add("parent-private");
        } else {
          observations.add("parent-public");
        }
        if (fileExists(repoDirectory("pnpm-workspace.yaml"))) {
          observations.add("pnpmWorkspaces");
        }
      } catch {
        observations.add("no-parent-repo");
      }
    }
    if (hasMainExport()) {
      observations.add("cjs");
    }
    if (hasModuleExport()) {
      observations.add("esm");
    }
    if (hasTypingsExport()) {
      observations.add("typings");
    }
    const lint = determineLinter();
    observations = /* @__PURE__ */ new Set([...observations, ...lint.observations]);
  }
  return observations;
}

// src/shared/observations/hasShellCommandInPath.ts
import { spawnSync as spawnSync3 } from "child_process";
var hasShellCommandInPath = (cmd) => {
  try {
    const results = spawnSync3("which", [cmd], { encoding: "utf8", stdio: "ignore" });
    return results.status === 0 ? true : false;
  } catch {
    return false;
  }
};

// src/shared/npm/crud/installDevDep.ts
async function installDevDep(opts, observations, ...packages) {
  const log = logger(opts);
  const pkgManager = await determinePackageManager({ ...opts, interactive: true }, observations);
  const cmd = pkgManager === "npm" ? `npm install --save-dev ${packages.join(" ")}` : `${pkgManager} add ${pkgManager === "yarn" ? "--dev" : "--save-dev"} ${packages.join(" ")}`;
  log.whisper(`- installing with ${chalk56.blue(cmd)}`);
  try {
    execSync(cmd);
    log.info(
      `
- ${"\u{1F389}" /* checkmark */} package${packages.length > 1 ? "s" : ""} [ ${chalk56.italic.gray(packages.join(", "))} ] ${chalk56.italic`installed`} as dev dependency${packages.length > 1 ? "ies" : "y"}
`
    );
    return true;
  } catch (error) {
    log.info(chalk56.gray`${chalk56.red`failure`} trying to install npm packages: ${cmd}`);
    log.info(chalk56.gray`\n${error.message}\n`);
    return false;
  }
}

// src/shared/npm/crud/removeDep.ts
import { omit as omit3 } from "native-dash";
import chalk57 from "chalk";

// src/shared/npm/package-json/convertDepDictionaryToArray.ts
function convertDepDictionaryToArray(deps) {
  return Object.keys(deps).map((dep) => ({ name: dep, version: deps[dep] }));
}

// src/shared/npm/package-json/getPackageJson.ts
import fs6 from "fs";
import path30 from "path";
import parse9 from "destr";

// src/shared/npm/package-json/cache/packageJsonCache.ts
var packageJson;
var pathBasedPackageJson = {};
function getPackageJsonfromCache(overridePath) {
  return overridePath ? pathBasedPackageJson[overridePath] || false : packageJson ? packageJson : false;
}
function cacheLocalPackageJson(pkgJson, pathOverride) {
  if (pathOverride) {
    pathBasedPackageJson[pathOverride] = pkgJson;
  } else {
    packageJson = pkgJson;
  }
}

// src/shared/npm/package-json/getPackageJson.ts
function getPackageJson(pathOverride, force = false) {
  const p = !force ? getPackageJsonfromCache(pathOverride) : void 0;
  if (p) {
    return p;
  }
  const filename = path30.join(
    pathOverride?.replace("package.json", "") || process.cwd(),
    "package.json"
  );
  if (!fileExists(filename)) {
    throw new DevopsError(
      `Attempt to get package.json [${filename}] file failed`,
      "not-ready/missing-package-json"
    );
  }
  const pj = parse9(fs6.readFileSync(filename, { encoding: "utf-8" }));
  cacheLocalPackageJson(pj, pathOverride);
  return pj;
}

// src/shared/npm/package-json/dependencies.ts
function dependencies(dir) {
  const pkg = getPackageJson(dir);
  const dependencies2 = pkg.dependencies ? convertDepDictionaryToArray(pkg.dependencies) : [];
  const devDependencies = pkg.devDependencies ? convertDepDictionaryToArray(pkg.devDependencies) : [];
  const peerDependencies = pkg.peerDependencies ? convertDepDictionaryToArray(pkg.peerDependencies) : [];
  const optionalDependencies = pkg.optionalDependencies ? convertDepDictionaryToArray(pkg.optionalDependencies) : [];
  const total = dependencies2.length + devDependencies.length + peerDependencies.length + optionalDependencies.length;
  return {
    total,
    dependencies: dependencies2,
    devDependencies,
    peerDependencies,
    optionalDependencies,
    hasDependencies: dependencies2.length > 0,
    hasDevDependencies: devDependencies.length > 0,
    hasOptionalDependencies: optionalDependencies.length > 0,
    hasPeerDependencies: peerDependencies.length > 0
  };
}

// src/shared/npm/package-json/findPackageJson.ts
import { findUpSync as sync7 } from "find-up";
function findPackageJson(dir) {
  return sync7("package.json", { cwd: dir || parentDirectory() });
}

// src/shared/npm/package-json/getExportsFromPackageJson.ts
import { retain } from "native-dash";

// src/shared/npm/package-json/getExternalPackageJson.ts
import { asyncExec as asyncExec5 } from "async-shelljs";
import parse10 from "destr";
async function getExternalPackageJson(pkg = "") {
  try {
    return parse10(await asyncExec5(`npm info ${pkg} --json`, { silent: true }));
  } catch {
    throw new DevopsError(
      pkg ? `The package ${pkg} does not exist in NPM.` : "The local package does not exist in NPM.",
      "devops/does-not-exist"
    );
  }
}

// src/shared/npm/package-json/hasDependency.ts
function hasDependency(dep, pathOveride) {
  try {
    const pkg = getPackageJson(pathOveride);
    const deps = pkg.dependencies;
    return deps && deps[dep];
  } catch {
    return false;
  }
}

// src/shared/npm/package-json/hasDevDependency.ts
function hasDevDependency(dep, pathOveride) {
  try {
    const pkg = getPackageJson(pathOveride);
    const devDeps = pkg.devDependencies;
    return devDeps && devDeps[dep];
  } catch {
    return false;
  }
}

// src/shared/npm/package-json/hasMainExport.ts
import path31 from "path";
function hasMainExport(dep) {
  if (dep) {
    dep = path31.join(
      process.cwd(),
      "node_modules/",
      `${dep.replace(/\/{0,1}node_modules\/{0,1}/, "")}`
    );
  }
  const pkg = dep ? getPackageJson(dep) : getPackageJson();
  return pkg.main && pkg.main.length > 0 ? true : false;
}

// src/shared/npm/package-json/hasModuleExport.ts
import path32 from "path";
function hasModuleExport(dep) {
  if (dep) {
    dep = path32.join(
      process.cwd(),
      "node_modules/",
      `${dep.replace(/\/{0,1}node_modules\/{0,1}/, "")}`
    );
  }
  const pkg = dep ? getPackageJson(dep) : getPackageJson();
  return pkg.module && pkg.module.length > 0 ? true : false;
}

// src/shared/npm/package-json/hasScript.ts
function hasScript(script, dep) {
  if (dep) {
    dep = `node_modules/${dep.replace(/\/{0,1}node_modules\/{0,1}/, "")}`;
  }
  const pkg = dep ? getPackageJson(dep) : getPackageJson();
  return Object.keys(pkg.scripts || {}).includes(script);
}

// src/shared/npm/package-json/hasTypings.ts
import path33 from "path";
function hasTypingsExport(dep) {
  if (dep) {
    dep = path33.join(
      process.cwd(),
      "node_modules/",
      `${dep.replace(/\/{0,1}node_modules\/{0,1}/, "")}`
    );
  }
  const pkg = dep ? getPackageJson(dep) : getPackageJson();
  return pkg.typings || pkg.types ? true : false;
}

// src/shared/npm/package-json/pkgDepsInTable.ts
import chalk58 from "chalk";
function formatDependencies(deps) {
  return deps.map((dep) => `${chalk58.bold(dep.name)} [ ${chalk58.dim(dep.version)} ]`);
}
function pkgDepsInTable(opts = {}) {
  const { dependencies: dependencies2, devDependencies, optionalDependencies, peerDependencies } = getPackageJson();
  const deps = [
    { name: "Dependencies", data: opts.ignoreDeps ? void 0 : dependencies2 },
    { name: "Peer Deps", data: opts.ignorePeerDeps ? void 0 : peerDependencies },
    { name: "Optional Deps", data: opts.ignoreOptionalDeps ? void 0 : optionalDependencies },
    { name: "Dev Deps", data: opts.ignoreDevDeps ? void 0 : devDependencies }
  ].filter((i) => i.data && Object.keys(i.data).length > 0).map((i) => ({
    name: i.name,
    data: formatDependencies(convertDepDictionaryToArray(i.data))
  }));
  const columns = deps.map((i) => i.name);
  const max = Math.max(...deps.map((d) => d.data.length));
  const data = [];
  for (let idx = 0; idx < max; idx++) {
    const row = {};
    for (const col of columns) {
      const datum = deps.find((c) => c.name === col)?.data || [];
      row[col] = datum[idx] ?? "";
    }
    data.push(row);
  }
  return toTable(data, ...columns);
}

// src/shared/npm/package-json/savePackageJson.ts
import { writeFile as writeFile5 } from "fs";
import { promisify as promisify6 } from "util";
var write4 = promisify6(writeFile5);

// src/shared/npm/package-manager/pm-constants.ts
var PACKAGE_MANAGERS = [
  "npm",
  "pnpm",
  "yarn",
  "cargo"
];
var PKG_MGR_LOCK_FILE_LOOKUP = {
  npm: "package-lock.json",
  pnpm: "pnpm-lock.yaml",
  yarn: "yarn.lock",
  cargo: "Cargo.toml"
};

// src/shared/npm/package-manager/removeOtherLockFiles.ts
async function removeOtherLockFiles(pkgMgr) {
  const toRemove = PACKAGE_MANAGERS.filter((i) => i !== pkgMgr);
  const files = [];
  for (const mngr of toRemove) {
    const file = PKG_MGR_LOCK_FILE_LOOKUP[mngr];
    const filepath = currentDirectory(file);
    if (fileExists(filepath)) {
      files.push(file);
      removeFile(filepath);
    }
  }
  return files;
}

// src/shared/core/util/doDevopsVersion.ts
function doDevopsVersion() {
  const libPkgJsonFilename = libraryDirectory();
  try {
    const version = fileExists(libPkgJsonFilename) ? getPackageJson(libPkgJsonFilename).version || "?" : "??";
    return version;
  } catch (error) {
    console.log(
      chalk59.gray` - ${"\u{1F4A9}" /* poop */} failed to detect do-devops version: ${error.message}`
    );
    console.log(chalk59.gray` - library directory reported as being: ${libPkgJsonFilename}`);
    return "?";
  }
}

// src/shared/core/util/commandAnnouncement.ts
function commandAnnouncement(cmdDefn, cmd) {
  const log = logger(cmd ? cmd.opts : {});
  const version = doDevopsVersion();
  const argv = cmd && cmd.argv.length > 0 ? chalk60.italic` ${cmd.argv.join(" ")}` : "";
  const subCmd = cmd && cmd.subCommand ? chalk60.dim`  ${cmd.subCommand}` : "";
  const helpText = !cmdDefn && !cmd || cmd && cmd.opts?.help ? cmdDefn ? ` [ help, v${version} ]` : `  v${version}` : "";
  const brand = cmdDefn ? chalk60.green.italic.bold(`${cmdDefn.kind}${subCmd}${argv}`) : chalk60.green.italic.bold("Help");
  log.info(
    chalk60.bold(
      `
do-devops ${brand}${chalk60.gray(helpText)}
`
    )
  );
}

// src/shared/core/util/finalizeCommandDefinition.ts
import chalk61 from "chalk";
function finalizeCommandDefinition(cmdDefn, observations, options15 = {}) {
  const isGlobal = cmdDefn ? false : true;
  const d1 = isDynamicCommandDefinition(cmdDefn.description) ? cmdDefn.description(observations, options15) : cmdDefn.description;
  const description13 = isCommandDescriptor(d1) ? isGlobal ? d1.short : d1.complete : d1;
  const subCommands3 = isDynamicCommandDefinition(cmdDefn.subCommands) ? cmdDefn.subCommands(observations, options15) : cmdDefn.subCommands;
  const argv = hasArgv(cmdDefn) ? ` [${chalk61.dim`argv`}]` : "";
  const argvStatic = chalk61.bold.blue("[argv]:");
  const argvDescription = getArgvOption(cmdDefn)?.description ? `

		${argvStatic} ${getArgvOption(cmdDefn)?.description}` : "";
  const subCommandSyntax = subCommands3 && subCommands3.length > 0 ? ` ${chalk61.bold`<cmd:`}${chalk61.dim(subCommands3.map((i) => i.name).join(`${chalk61.blue.bold`|}`}`))}${chalk61.bold`>`}` : "";
  return {
    kind: cmdDefn.kind,
    handler: cmdDefn.handler,
    syntax: cmdDefn.syntax || `dd ${cmdDefn.kind}${subCommandSyntax}${argv} [${chalk61.dim.italic`options`}]${argvDescription}`,
    description: description13,
    subCommands: subCommands3,
    options: { ...cmdDefn.options, ...globalOptions },
    hiddenCommand: false
  };
}

// src/shared/core/util/formatCommandsSection.ts
import chalk62 from "chalk";
import { isOdd } from "native-dash";
function formatCommandsSection(subCommands3, cmd) {
  return {
    header: cmd ? `Sub-Commands for {bold ${cmd}}` : `Commands`,
    content: subCommands3.map((sc, idx) => ({
      name: isOdd(idx) ? chalk62.dim`${sc.name}` : sc.name,
      summary: isOdd(idx) ? chalk62.dim`${sc.summary}` : sc.summary
    }))
  };
}

// src/shared/core/util/globalCommandDescriptions.ts
function globalCommandDescriptions(observations) {
  return getAllCommands(observations).map((i) => {
    return {
      name: i.kind,
      summary: i.description
    };
  });
}

// src/shared/core/help.ts
function help(observations, cmdDefn) {
  const { kind, subCommands: subCommands3, description: description13, syntax: syntax3, options: options15 } = cmdDefn ? finalizeCommandDefinition(cmdDefn, observations) : {
    subCommands: globalCommandDescriptions(observations),
    description: "do-devops is a set of utility functions designed to make DevOps more fun in less time",
    syntax: "dd [cmd] [options]",
    options: globalOptions
  };
  const sections = [
    {
      header: "Description",
      content: description13
    },
    {
      header: "Syntax",
      content: syntax3
    }
  ];
  if (subCommands3) {
    sections.push(formatCommandsSection(subCommands3, kind));
  }
  const defaultOptions = [];
  const o = options15 || {};
  if (kind) {
    sections.push({
      header: "Options",
      optionList: Object.keys(o).reduce((acc, key) => {
        if (o[key].defaultOption) {
          defaultOptions.push({ ...o[key], name: key });
          return acc;
        }
        return [...acc, { ...o[key], name: key }];
      }, [])
    });
  }
  try {
    console.log(commandLineUsage(sections));
  } catch (error) {
    console.log(
      `  - ${"\u{1F4A9}" /* poop */}  ${chalk63.red("Problem displaying help:")} ${error.message}
`
    );
    console.log(chalk63.grey(error.stack));
  }
  console.log();
  process.exit(-1);
}

// src/shared/core/helpContent.ts
import chalk106 from "chalk";

// src/commands/add/index.ts
var command = {
  kind: "add",
  handler: async ({ observations, raw }) => {
    await proxyToPackageManager("install", observations, raw);
    process.exit();
  },
  description: `proxies your package manager's {bold italic install / add } command`
};
var add_default = command;

// src/commands/autoindex/parts/autoindex.ts
import chalk69 from "chalk";
import { dirname as dirname4 } from "pathe";

// src/commands/autoindex/private/exclusions.ts
function exclusions(indexFileContent) {
  const hasExclusions = /^\/\/\s*#autoindex.*,\s*exclude:/;
  return hasExclusions.test(indexFileContent) ? indexFileContent.replace(/^\/\/\s*#autoindex.*,\s*exclude:([^\n;|]*)[\n;|][^\0]*/g, "$1").split(",").map((i) => i.trim()) : [];
}

// src/commands/autoindex/private/processFiles.ts
import chalk67 from "chalk";

// src/commands/autoindex/private/util/askHowToHandleMonoRepoIndexing.ts
import inquirer9 from "inquirer";

// src/commands/autoindex/private/util/communicateApi.ts
import chalk64 from "chalk";

// src/commands/autoindex/private/export-formats/generateSfcExports.ts
import chalk65 from "chalk";
function syncExport(f, content) {
  content += `export { default as ${removeExtension(f)} } from "./${f}";
`;
  return content;
}
function asyncExport(f, content) {
  content += `export const ${removeExtension(f)} = defineAsyncComponent({
`;
  content += `  loader: async () => import("./${f}") /** webpackChunkName: "${removeExtension(
    f
  )}" */,
`;
  content += `});
`;
  return content;
}
function generateSfcExports(indexFile, opts) {
  const log = logger(opts);
  const vueFiles = indexFile.files.filter((f) => f.includes(".vue"));
  if (!opts.sfc || vueFiles.length === 0) {
    return "";
  }
  let content = "// SFC Components\n";
  const pc = getProjectConfig();
  if (opts.async || pc.autoindex?.asyncSfc) {
    let asyncCount = 0;
    vueFiles.map((f) => {
      const useAsync = (pc.autoindex?.asyncExceptions || []).every((v) => !f.includes(v));
      if (useAsync) {
        content = asyncExport(f, content);
        asyncCount = asyncCount + 1;
      } else {
        content = syncExport(f, content);
      }
    });
    return asyncCount > 0 ? `import { defineAsyncComponent } from "vue";
${content}` : content;
  } else {
    if (opts.sfc && pc.autoindex?.asyncSfc === void 0) {
      log.info(
        `- you have stated that you want SFC exported but ${chalk65.italic`not`} if you want them to be asynchronous. Consider setting the ${chalk65.blue`autoindex.asyncSfc`} property in your do-devops config file.`
      );
    }
    vueFiles.map((f) => syncExport(f, content));
  }
  return content;
}

// src/commands/autoindex/private/util/createAutoindexContent.ts
function createAutoindexContent(indexFile, opts) {
  let autoIndexContent = "";
  switch (indexFile.exportType) {
    case "default" /* default */:
      autoIndexContent = defaultExports(indexFile, opts);
      break;
    case "namedOffset" /* namedOffset */:
      autoIndexContent = namedOffsetExports(indexFile, opts);
      break;
    case "named" /* named */:
      autoIndexContent = namedExports2(indexFile, opts);
      break;
    default:
      throw new DevopsError(`Unknown export type: ${indexFile.exportType}!`, "invalid-export-type");
  }
  return `${START_REGION}
${timestamp()}
// hash-code: ${indexFile.hashCode}

${autoIndexContent}
${generateSfcExports(indexFile, opts)}
${END_REGION}

${AUTOINDEX_INFO_MSG}
`;
}

// src/commands/autoindex/private/util/detectExportType.ts
function detectExportType(fileContent) {
  const defaultExport = /^\/\/\s*#autoindex:\s*default/;
  const namedOffsetExport = /^\/\/\s*#autoindex:\s*named-offset/;
  const offsetExport = /^\/\/\s*#autoindex:\s*offset/;
  if (defaultExport.test(fileContent)) {
    return "default" /* default */;
  }
  if (namedOffsetExport.test(fileContent) || offsetExport.test(fileContent)) {
    return "namedOffset" /* namedOffset */;
  }
  return "named" /* named */;
}

// src/commands/autoindex/private/util/isAutoindexFile.ts
import chalk66 from "chalk";
import { readFileSync as readFileSync6, writeFileSync as writeFileSync5 } from "fs";

// src/commands/autoindex/private/reference/constants.ts
var START_REGION = "// #region auto-indexed files";
var END_REGION = "// #endregion auto-indexed files";
var OLD_START_REGION = "// #region autoindexed files";
var AUTOINDEX_INFO_MSG = "// see https://github.com/inocan-group/do-devops/docs/autoindex.md\n// for more info";
var NEW_AUTOINDEX_CONTENT = `// #autoindex
`;

// src/commands/autoindex/private/util/isAutoindexFile.ts
function isAutoindexFile(filename) {
  const log = logger();
  const file = readFileSync6(filename, "utf8");
  const isEmpty = file.trim() === "";
  const hasSignature = /\/\/\s*#autoindex/.test(file);
  if (isEmpty) {
    log.shout(`- ${"\u{1F632}" /* shocked */} the index file ${chalk66.blue`${filename}} was EMPTY!`}`);
    writeFileSync5(filename, NEW_AUTOINDEX_CONTENT);
    log.shout(`- ${"\u{1F916}" /* robot */} made this file into an ${chalk66.italic`autoindex`} file
`);
    return true;
  }
  return isEmpty || hasSignature;
}
function isNewAutoindexFile(content) {
  return /\/\/\s+#autoindex/s.test(content) && !/\/\/ index last changed/s.test(content);
}

// src/commands/autoindex/private/util/isOrphanedIndexFile.ts
function isOrphanedIndexFile(indexFileContents) {
  const re = /\/\/\s*#\s*autoindex.+orphan/m;
  return re.test(indexFileContents);
}

// src/commands/autoindex/private/util/getEmbeddedHashCode.ts
function getEmbeddedHashCode(indexFileContent) {
  const re = /hash-code: (\S*)/m;
  const matches = indexFileContent.match(re);
  return Array.isArray(matches) ? String(matches[1]) : void 0;
}

// src/commands/autoindex/private/util/removeExtension.ts
function removeExtension(file) {
  const parts = file.split(".");
  const [fn] = parts.length > 2 ? [file.replace("." + parts[parts.length - 1], ""), parts[parts.length - 1]] : file.split(".");
  return fn;
}

// src/commands/autoindex/private/util/replaceRegion.ts
function replaceRegion(fileContent, regionContent) {
  const startRegion = new RegExp(`${START_REGION}.*`, "gs");
  const oldStartRegion = new RegExp(`${OLD_START_REGION}.*`, "gs");
  const re = startRegion.test(fileContent) ? startRegion : oldStartRegion;
  return fileContent.replace(re, regionContent);
}

// src/commands/autoindex/private/util/replaceOldHelpContent.ts
function hasOldHelpContent(content) {
  return content.includes("// This file was created by") ? true : false;
}

// src/commands/autoindex/private/util/timestamp.ts
import { format as format2 } from "date-fns";
function timestamp() {
  return `// index last changed at: ${format2(Date.now(), "Mo MMM, yyyy, hh:mm a ( O )")}`;
}

// src/commands/autoindex/private/processFiles.ts
import { dirname as dirname2, join as join12 } from "pathe";
import { writeFile as writeFile6 } from "fs/promises";
import { existsSync as existsSync10, readFileSync as readFileSync7 } from "fs";
import xxhash from "xxhash-wasm";
import { cwd as cwd3 } from "process";
import { relative as relative2 } from "path";
async function processFiles(group, options15, _o) {
  const log = logger(options15);
  let { contentFiles, indexFiles, nonAutoindexFiles } = group;
  const { h32 } = await xxhash();
  const totalCount = indexFiles.length + nonAutoindexFiles.length;
  if (indexFiles.length === 0) {
    log.info(`- ${"\u{1F914}" /* confused */} no ${chalk67.italic`autoindex`} files found in this package`);
    return;
  } else {
    log.info(
      `- ${chalk67.yellow.bold(indexFiles.length)} autoindex files found (${chalk67.dim`out of ${chalk67.yellow(String(totalCount))}`} candidates)`
    );
    log.whisper(`- index files were: ${chalk67.gray`${indexFiles.join(", ")}}`}`);
  }
  for (const indexFilename of indexFiles) {
    let action;
    const dir = dirname2(indexFilename);
    const indexFileContent = readFileSync7(indexFilename, "utf8");
    const explicitExcludes = exclusions(indexFileContent);
    const exportType = detectExportType(indexFileContent);
    const subDirs = getSubdirectories(join12(cwd3(), dir));
    const filesAtSameLevel = directoryFiles(join12(cwd3(), dir)).map((f) => f.file).map((i) => join12(dir, i));
    contentFiles = filesAtSameLevel.filter(
      (f) => (f.endsWith(".js") || f.endsWith(".ts") || f.endsWith(".vue") && options15.sfc) && !f.endsWith("index.js") && !f.endsWith("index.ts")
    );
    const noExports = contentFiles.filter((f) => !fileHasExports(f));
    const remaining = contentFiles.length - noExports.length;
    log.whisper(
      `- processing the ${chalk67.bold.italic`autoindex`} file in ${chalk67.blue(dir)} [${chalk67.dim(exportType)} ${chalk67.italic`export`}, ${remaining} of ${contentFiles.length} ${chalk67.italic`files`}, ${subDirs.length} ${chalk67.italic`sub directories`}]`
    );
    if (contentFiles.length === 0) {
      log.whisper(`- there are no files in ${dir} which were found to export symbols!`);
      return;
    }
    log.whisper(
      `- content files are:
	${chalk67.gray(contentFiles.map(
        (f) => `${highlightFilepath(relative2(cwd3(), f))} [${noExports.includes(f) ? "x" : "\u2713"}]`
      ).join("\n	"))}`
    );
    if (noExports.length > 0) {
      for (const f of noExports) {
        log.whisper(`- the file ${chalk67.red(f)} will be ignored because it has no exports`);
      }
      if (contentFiles.length === noExports.length) {
        log.info(
          `- the directory ${chalk67.blue(dir)} had  ${chalk67.yellow(contentFiles.length)} files which ${chalk67.italic`could`} have exported symbols but ${chalk67.bold`none did`}.`
        );
      } else {
        log.info(
          `- the directory ${chalk67.blue(dir)} had ${chalk67.yellow(contentFiles.length)} files which ${chalk67.italic(`could`)} have had export symbols but ${chalk67.yellow(noExports.length)} ${chalk67.bold`did not`}.`
        );
      }
    }
    contentFiles = noExports.length > 0 ? contentFiles.filter((i) => noExports.includes(i)) : contentFiles;
    const orphans = [];
    const noIndexFile = [];
    const explicitDirRemoval = [];
    const noExportDir = [];
    const dirs = getSubdirectories(dir).reduce((acc, d) => {
      const ts2 = join12(dir, d, "/index.ts");
      const js = join12(dir, d, "/index.js");
      const child = ts2 || js;
      if (!existsSync10(child)) {
        log.whisper(
          chalk67.gray(
            ` - will not include the ${chalk67.blue(d)}} directory because there is ${chalk67.italic.red`no index file`}`
          )
        );
        noIndexFile.push(d);
        return acc;
      } else if (isOrphanedIndexFile(child)) {
        log.whisper(
          chalk67.gray(
            ` - will not include the directory ${chalk67.blue(d)}} because it is configured as an ${chalk67.italic.red`orphan`}`
          )
        );
        orphans.push(d);
        return acc;
      } else if (!explicitExcludes.every((e) => d !== e)) {
        log.whisper(
          chalk67.gray(
            ` - will not include the directory ${chalk67.blue(d)}} because it is configured as an ${chalk67.italic.red`orphan`}`
          )
        );
        explicitDirRemoval.push(d);
        return acc;
      } else if (!fileHasExports(child)) {
        log.whisper(
          chalk67.gray` - will not include the directory ${chalk67.blue(d)}} because it has ${chalk67.italic.red`no exports`}`
        );
        noExportDir.push(d);
        return acc;
      }
      return [...acc, d];
    }, []);
    const fileSymbols = contentFiles.map((f) => getFileComponents(f).filename);
    const priorHash = isNewAutoindexFile(indexFileContent) ? void 0 : getEmbeddedHashCode(indexFileContent);
    const hashCode = String(h32(
      JSON.stringify({
        fileSymbols,
        dirs,
        explicitExcludes,
        orphans,
        noIndexFile,
        exportType,
        explicitDirRemoval,
        noExportDir,
        sfc: options15.sfc || false
      }),
      3405691582
    ));
    const content = {
      exportType,
      files: fileSymbols,
      dirs,
      hashCode
    };
    const hasChanged = priorHash !== hashCode || options15.force === true || hasOldHelpContent(indexFileContent);
    if (hasChanged) {
      action = isNewAutoindexFile(indexFileContent) ? "new-file" : "updated";
      const result = createAutoindexContent(content, options15);
      const fileContent = action === "new-file" ? result : replaceRegion(indexFileContent, result);
      if (options15.dryRun) {
        log.dryRun(`index file "${indexFilename}" would be written because: ${action}`);
      } else {
        writeFile6(indexFilename, fileContent, "utf8");
      }
    } else {
      action = "unchanged";
      if (options15.dryRun) {
        log.dryRun(chalk67.dim(`index file "${chalk67.bold(indexFilename)}" will not be changed as it has not changed`));
      }
    }
    if (!options15.dryRun) {
      switch (action) {
        case "new-file": {
          log.info(
            `- autoindex file ${highlightFilepath(indexFilename)} is a ${chalk67.bold.italic("new")}} file")`
          );
          break;
        }
        case "updated": {
          log.info(
            `- autoindex file ${highlightFilepath(indexFilename)} was ${chalk67.bold.italic("updated")}.`
          );
          break;
        }
        case "unchanged": {
          const talk = options15.explicitFiles ? log.info : log.whisper;
          talk(
            `${chalk67.dim(` - autoindex file ${highlightFilepath(
              indexFilename
            )} was left ${chalk67.italic.bold(" unchanged")}.`)}`
          );
          break;
        }
      }
    }
  }
}

// src/commands/autoindex/private/export-formats/defaultExports.ts
function defaultExports(ai, opts = {}) {
  const file = (file2) => `export { default as ${removeExtension(file2)} } from "./${opts.preserveExtension ? removeExtension(file2) + ".js" : removeExtension(file2)}";
`;
  const dir = (dir2) => `export { default as ${removeExtension(dir2)} } from "./${dir2}/index${opts.preserveExtension ? ".js" : ""}";
`;
  const nonVueFiles = ai.files.filter((f) => !f.includes(".vue"));
  return [
    ...nonVueFiles.length > 0 ? ["// file exports"] : [],
    ...nonVueFiles.length > 0 ? nonVueFiles.map((f) => file(f)) : [],
    ...ai.dirs.length > 0 ? ["// directory exports"] : [],
    ...ai.dirs.length > 0 ? ai.dirs.map((f) => dir(f)) : []
  ].filter((i) => i).join("\n");
}

// src/commands/autoindex/private/export-formats/namedExports.ts
function namedExports2(ai, opts = {}) {
  const file = (file2) => `export * from "./${opts.preserveExtension ? removeExtension(file2) + ".js" : removeExtension(file2)}";`;
  const dir = (dir2) => `export * from "./${dir2}/index${opts.preserveExtension ? ".js" : ""}";`;
  const nonVueFiles = ai.files.filter((f) => !f.includes(".vue"));
  return [
    ...nonVueFiles.length > 0 ? ["// file exports"] : [],
    ...nonVueFiles.length > 0 ? nonVueFiles.map((f) => file(f)) : [],
    ...ai.dirs.length > 0 ? ["// directory exports"] : [],
    ...ai.dirs.length > 0 ? ai.dirs.map((f) => dir(f)) : []
  ].filter((i) => i).join("\n");
}

// src/commands/autoindex/private/export-formats/namedOffsetExports.ts
function namedOffsetExports(ai, opts = {}) {
  const file = (file2) => `export * as ${removeExtension(file2)} from "./${opts.preserveExtension ? removeExtension(file2) + ".js" : removeExtension(file2)}";
`;
  const dir = (dir2) => `export * as ${dir2} from "./${dir2}/index${opts.preserveExtension ? ".js" : ""}";
`;
  const nonVueFiles = ai.files.filter((f) => !f.includes(".vue"));
  return [
    ...nonVueFiles.length > 0 ? ["// file exports"] : [],
    ...nonVueFiles.length > 0 ? nonVueFiles.map((f) => file(f)) : [],
    ...ai.dirs.length > 0 ? ["// directory exports"] : [],
    ...ai.dirs.length > 0 ? ai.dirs.map((f) => dir(f)) : []
  ].filter((i) => i).join("\n");
}

// src/commands/autoindex/parts/watch.ts
import chalk68 from "chalk";
import { spawn } from "child_process";
import w from "chokidar";
import { existsSync as existsSync11 } from "fs";
import { dirname as dirname3, join as join13 } from "pathe";
import { cwd as cwd4 } from "process";
var deferredFiles = /* @__PURE__ */ new Set();
function recheck(autoindexFile, log) {
  const cmd = ["dd", "autoindex", "--quiet", autoindexFile];
  try {
    const check = spawn("npx", cmd, { stdio: "inherit", cwd: process.cwd() });
    check.on("error", (error) => {
      throw error;
    });
    const promise = new Promise((resolve) => {
      check.on("exit", () => resolve(true));
      check.on("disconnect", () => resolve(true));
      check.on("close", () => resolve(true));
    });
    return promise;
  } catch (error) {
    log.shout(
      `- ${"\u{1F4A9}" /* poop */} problems re-running autoindex on ${highlightFilepath(autoindexFile)}: ${error.message}`
    );
    return Promise.resolve(false);
  }
}
function recheckAutoindexFile(changedFile, log) {
  const dir = dirname3(changedFile);
  const autoindexFile = existsSync11(join13(process.cwd(), dir, "/index.ts")) ? join13(dir, "/index.ts") : existsSync11(join13(process.cwd(), dir, "/index.js")) ? join13(dir, "/index.js") : void 0;
  if (autoindexFile) {
    recheck(autoindexFile, log);
  } else {
    log.info(
      `- ${"\u{1F914}" /* confused */} there was a problem identifying the right ${chalk68.italic`autoindex`} file for ${chalk68.blue(changedFile)}`
    );
  }
}
function contentWatcher(group, op, log) {
  return (file) => {
    switch (op) {
      case "add": {
        log.info(
          `- ${chalk68.bold("Autoindex:")} ${chalk68.dim.italic(" repo ")} ${chalk68.blue(group.name)} ${chalk68.italic`added the file `}${highlightFilepath(file)}}`
        );
        if (fileHasExports(join13(process.cwd(), file))) {
          recheckAutoindexFile(file, log);
        } else {
          deferredFiles.add(file);
          log.info(
            chalk68.dim(`- ${chalk68.bold("Autoindex:")} the file has no ${chalk68.italic`exports`} yet so deferring update`)
          );
        }
        break;
      }
      case "unlink": {
        log.info(
          `- ${chalk68.bold("Autoindex:")} ${chalk68.dim.italic(" repo ")} ${chalk68.blue(group.name)} ${chalk68.italic`removed the file `}${highlightFilepath(file)}}`
        );
        recheckAutoindexFile(file, log);
        break;
      }
      case "changed": {
        const hasExports = fileHasExports(join13(process.cwd(), file));
        const wasDeferred = deferredFiles.has(file);
        if (hasExports && wasDeferred) {
          log.info(
            `- ${chalk68.bold("Autoindex:")} ${chalk68.dim.italic(" repo ")} ${chalk68.blue(
              group.name
            )} ${chalk68.italic`changed`}${highlightFilepath(file)} ${chalk68.italic`which now has exports`}`
          );
          deferredFiles.delete(file);
          recheckAutoindexFile(file, log);
        } else if (!hasExports) {
          log.info(
            `- ${chalk68.bold("Autoindex:")} ${chalk68.dim.italic(" repo ")} ${chalk68.blue(
              group.name
            )} ${chalk68.italic`changed`}${highlightFilepath(file)} ${chalk68.italic`and no longer has exports`}`
          );
          recheckAutoindexFile(file, log);
        }
        break;
      }
      default: {
        log.info(
          `- ${chalk68.bold("Autoindex:")} ${chalk68.dim.italic(" repo ")} ${chalk68.blue(group.name)} ${chalk68.italic`did "${op}" to `}${highlightFilepath(file)}}`
        );
      }
    }
  };
}
function getParentIndex(file) {
  const dir = dirname3(file).split("/");
  const ts2 = join13(dir.slice(0, -1).join("/"), "index.ts");
  const js = join13(dir.slice(0, -1).join("/"), "index.js");
  return existsSync11(ts2) ? ts2 : existsSync11(js) ? js : void 0;
}
function idxWatcher(group, op, log) {
  return (file) => {
    switch (op) {
      case "add": {
        if (isAutoindexFile(file)) {
          log.info(
            `- ${chalk68.bold("Autoindex:")} ${chalk68.dim.italic(" repo ")} ${chalk68.blue(group.name)} ${chalk68.italic`added a new autoindex file `}${highlightFilepath(file)}}`
          );
          recheck(file, log).then((successful) => {
            if (successful) {
              const parentIndex = getParentIndex(file);
              if (parentIndex) {
                recheck(parentIndex, log);
              }
            } else {
              log.info(
                chalk68.dim.red` - autoindex update failed to update ${highlightFilepath(file)}`
              );
            }
          });
        }
        break;
      }
      case "unlink": {
        log.info(
          `- ${chalk68.bold("Autoindex:")} ${chalk68.italic("repo")} ${chalk68.blue(group.name)} ${chalk68.italic("removed an autoindex file ")}${highlightFilepath(file)}}""`
        );
        const parentIndex = getParentIndex(file);
        if (parentIndex) {
          recheck(parentIndex, log);
        }
        break;
      }
      case "change": {
        log.info(
          `- ${chalk68.bold("Autoindex:")} ${chalk68.dim.italic(" repo ")} ${chalk68.blue(group.name)} ${chalk68.italic("changed an autoindex file ")}${highlightFilepath(file)}}`
        );
        recheck(file, log);
        break;
      }
      default: {
        log.info(`Unexpected operation [${op}] passed to the index watcher`);
      }
    }
  };
}
var groups = [];
function addWatcher(group, opts, type, log) {
  const watcher = w.watch(type === "index" ? group.indexGlobs : group.contentGlobs, opts);
  switch (type) {
    case "content": {
      watcher.on("ready", () => {
        watcher.on("add", contentWatcher(group, "add", log));
        watcher.on("unlink", contentWatcher(group, "unlink", log));
        watcher.on("change", contentWatcher(group, "changed", log));
        watcher.on("remove", contentWatcher(group, "remove", log));
      });
      break;
    }
    case "index": {
      watcher.on("ready", () => {
        watcher.on("add", idxWatcher(group, "add", log));
        watcher.on("unlink", idxWatcher(group, "unlink", log));
        watcher.on("change", idxWatcher(group, "change", log));
      });
      break;
    }
  }
  return watcher;
}
function watch(group, opts) {
  const log = logger(opts);
  const indexWatcher = addWatcher(
    group,
    {
      cwd: join13(cwd4(), group.path)
    },
    "index",
    log
  );
  const contentWatcher2 = addWatcher(
    group,
    {
      cwd: join13(cwd4(), group.path)
    },
    "content",
    log
  );
  groups.push({ ...group, indexWatcher, contentWatcher: contentWatcher2 });
  log.info();
  log.info(`Watching ${group.name}:`);
  log.info(` - this includes ${chalk68.yellow(group.indexFiles.length)} index files`);
  log.info(` - and${chalk68.yellow(group.contentFiles.length)} content files`);
  log.info();
}

// src/commands/autoindex/parts/autoindex.ts
import { exit as exit6 } from "process";

// src/commands/autoindex/parts/getGlobs.ts
import { globby as globby5 } from "globby";
import { join as join14 } from "path";
import { cwd as cwd5 } from "process";
var REQUIRED_BLACKLIST = [
  "**/node_modules/**",
  "**/index.ts",
  "**/index.js",
  "**/index.cjs",
  "**/index.mjs"
];
var INDEX_LIST_DEFAULTS = [
  "**/index.ts",
  "**/index.js",
  "**/index.mjs",
  "**/index.cjs",
  "!**/node_modules",
  "!**/dist"
];
var WHITE_LIST_DEFAULTS = ["src/**/*.ts", "src/**/*.js"];
var BLACK_LIST_DEFAULTS = ["**/*.d.ts", "packages/**/*", "dist/**", ".webpack/**"];
async function getIndex(path35, _opts) {
  const packages = await getMonoRepoPackages(path35);
  const isRoot = path35 === ".";
  const exclusions2 = isRoot ? packages.filter((i) => i.path !== ".").map((i) => `!${i.path}/**`) : [];
  const indexGlobs = [...INDEX_LIST_DEFAULTS, ...exclusions2];
  const nonAutoindexFiles = [];
  const indexFiles = (await globby5(indexGlobs, { onlyFiles: true, cwd: join14(cwd5(), path35) })).filter(
    (f) => {
      if (isAutoindexFile(f)) {
        return true;
      } else {
        nonAutoindexFiles.push(f);
        return false;
      }
    }
  );
  return { indexFiles, indexGlobs, nonAutoindexFiles };
}
async function getContent(dir, opts) {
  const projectConfig = opts.explicitFiles ? getProjectConfig(".") : getProjectConfig(dir);
  const whiteGlobs = [
    ...projectConfig.autoindex?.whitelistGlobs || WHITE_LIST_DEFAULTS,
    ...opts.sfc ? ["**/*.vue"] : []
  ];
  const blackGlobs = [
    ...projectConfig.autoindex?.blacklistGlobs || BLACK_LIST_DEFAULTS,
    ...REQUIRED_BLACKLIST
  ].map((i) => i.startsWith("!") ? i : `!${i}`);
  const contentGlobs = [...whiteGlobs, ...blackGlobs];
  const contentFiles = await globby5(contentGlobs, {
    onlyFiles: true,
    cwd: join14(cwd5(), dir)
  });
  return { contentFiles, contentGlobs };
}

// src/commands/autoindex/parts/autoindex.ts
var handler = async ({ opts, observations, argv }) => {
  opts = {
    ...opts,
    sfc: opts.sfc === false ? false : true,
    explicitFiles: (argv?.length || 0) > 0
  };
  const log = logger(opts);
  if (opts.config) {
    await askForAutoindexConfig(opts, observations);
    process.exit();
  }
  const kind = opts.explicitFiles ? "explicit-files" : observations.has("monorepo") ? "monorepo" : "repo";
  const groups2 = [];
  switch (kind) {
    case "explicit-files": {
      log.info(
        `- you have passed in specific ${chalk69.italic`index`} files to evaluate [${chalk69.dim(argv.length)}]; we will group by each file ...`
      );
      for (const file of argv) {
        const baseDir = dirname4(file);
        const indexFiles = [file];
        const { contentGlobs, contentFiles } = await getContent(baseDir, opts);
        const pkg = {
          kind: "explicit-files",
          path: ".",
          name: `index file: ${file}`,
          indexGlobs: [file],
          indexFiles,
          contentGlobs,
          contentFiles,
          nonAutoindexFiles: []
        };
        groups2.push(pkg);
      }
      break;
    }
    case "repo": {
      const { indexGlobs, indexFiles, nonAutoindexFiles } = await getIndex(".", opts);
      const { contentGlobs, contentFiles } = await getContent(".", opts);
      log.whisper(chalk69.dim`- no monorepo detected so will run just once using glob patterns`);
      groups2.push({
        kind: "repo",
        path: ".",
        name: getPackageJson(process.cwd()).name || "unnamed",
        contentGlobs,
        indexGlobs,
        contentFiles,
        indexFiles,
        nonAutoindexFiles
      });
      break;
    }
    case "monorepo": {
      const subDirs = getSubdirectories(".");
      const hasSrcOrLibAtRoot = subDirs.includes("src") || subDirs.includes("lib");
      const repos = hasSrcOrLibAtRoot ? [
        { path: ".", name: getPackageJson(process.cwd()).name || "unnamed" },
        ...await getMonoRepoPackages(".", opts.exclude)
      ] : await getMonoRepoPackages(".", opts.exclude);
      for (const r of repos) {
        const { indexGlobs, indexFiles, nonAutoindexFiles } = await getIndex(r.path, opts);
        const { contentGlobs, contentFiles } = await getContent(r.path, opts);
        const group = {
          kind: "monorepo",
          ...r,
          indexFiles,
          indexGlobs,
          contentFiles,
          contentGlobs,
          nonAutoindexFiles
        };
        groups2.push(group);
      }
      if (groups2.length > 0) {
        log.info(
          `- ${"\u{1F440}" /* eyeballs */} monorepo detected with${chalk69.yellow(String(groups2.length))} packages`
        );
        for (const pkg of groups2) {
          log.info(chalk69.gray`  - ${chalk69.bold(pkg.name)} ${chalk69.italic("at")} ${chalk69.dim(pkg.path)}`);
        }
        log.info(`- \u26A1\uFE0F will run each package separately based on it's own configuration`);
      } else {
        log.info(
          `- after excluding packages -- ${chalk69.gray(opts.exclude?.join(", "))} -- no packages were left to run ${chalk69.bold`autoindex`} on
`
        );
        exit6(0);
      }
    }
  }
  const watchlist = [];
  for (const group of groups2) {
    if (groups2.length > 1) {
      log.info(`
- ${"\u{1F3C3}" /* run */} starting analysis of ${chalk69.blue(group.name)}`);
    }
    if (group.indexFiles.length > 0) {
      await processFiles(group, opts, observations);
    } else {
      log.info(`- ${"\u{1F914}" /* confused */} no ${chalk69.italic`index`} files found in ${chalk69.blue(group.name)}`);
    }
    if (opts.watch) {
      watchlist.push(group);
      watch(group, opts);
    }
  }
};

// src/commands/autoindex/parts/description.ts
var description = {
  short: `Automates the building of index files`,
  complete: `Automates the building of index files`
};

// src/commands/autoindex/parts/options.ts
var options2 = {
  explicitFiles: {
    defaultOption: true,
    multiple: true,
    type: String,
    group: "local",
    description: `optionally state one or more explicit autoindex files to evaluate instead of glob patterns`,
    typeLabel: "string[]"
  },
  config: {
    type: Boolean,
    group: "local",
    description: `configure autoindex for a project`
  },
  sfc: {
    type: Boolean,
    group: "local",
    description: `by default VueJS SFC files will be extracted as a default import but this can be turned off with this flag`
  },
  dryRun: {
    type: Boolean,
    group: "local",
    description: `allows getting a report on changes without actually making the changes`
  },
  dir: {
    type: String,
    group: "local",
    description: 'by default will look for files in the "src" directory but you can redirect this to a different directory'
  },
  exclude: {
    type: String,
    alias: "e",
    group: "local",
    multiple: true,
    description: "allow certain monorepos to be filtered out"
  },
  watch: {
    alias: "w",
    type: Boolean,
    group: "local",
    description: `watches for changes and runs autoindex when detected`
  },
  force: {
    alias: "f",
    type: Boolean,
    group: "local",
    description: "forces a rebuild of all autoindex files even if the hash-code appears to be unchanged"
  },
  preserveExtension: {
    alias: "p",
    type: Boolean,
    group: "local",
    description: `by default exports do not include the file's .js extension but sometimes with ES modules you want to include this. If you do then you should set this flag.`
  }
};

// src/commands/autoindex/index.ts
var command2 = {
  kind: "autoindex",
  handler,
  description,
  options: options2,
  config: askForAutoindexConfig
};
var autoindex_default = command2;

// src/commands/awsid/parts/awsid.ts
import chalk70 from "chalk";

// src/commands/awsid/private/askUser.ts
import inquirer10 from "inquirer";
async function askUser(profiles) {
  const question = checkboxQuestion({
    name: "profiles",
    message: "Choose the profiles you want ID's for",
    choices: profiles
  });
  const answer = await inquirer10.prompt([question]);
  return answer.profiles;
}

// src/commands/awsid/parts/awsid.ts
var handler2 = async ({ unknown: argv, opts }) => {
  const profiles = await getAwsProfileDictionary();
  const profileNames = Object.keys(profiles);
  let chosen = [];
  if (!profiles) {
    console.log(
      `- ${"\u{1F916}" /* robot */} you do not have ${chalk70.italic`any`} AWS profiles in your credentials file!
`
    );
    process.exit();
  }
  if (opts.all) {
    chosen = profileNames;
  } else if (argv.length === 0) {
    chosen = await askUser(Object.keys(profiles));
  } else {
    chosen = argv.filter((i) => profileNames.includes(i));
    if (chosen.length === 0) {
      console.log(`- there were {red no} valid profiles provided!`);
      console.log(`- valid profile names are: ${chalk70.blue(profileNames.join(", "))}`);
    }
    if (chosen.length !== argv.length) {
      console.log(`- some profiles provided were not valid; valid ones are listed below`);
    }
  }
  const results = [];
  const errors = [];
  for (const profile2 of chosen) {
    try {
      results.push({ profile: profile2, ...await getAwsIdentityFromProfile(profiles[profile2]) });
      process.stdout.write(`{green .}`);
    } catch (error) {
      errors.push({ error, profile: profile2 });
      process.stdout.write(`{red .}`);
    }
  }
  console.log();
  console.log(results);
  if (errors.length > 0) {
    console.log(
      `- there ${errors.length === 1 ? "was" : "were"} ${errors.length} profile${errors.length === 1 ? "" : "s"} which encountered errors trying to authenticate, the rest were fine.`
    );
    for (const e of errors) {
      console.log(
        `- ${chalk70.bold.red(e.profile)}: ${chalk70.grey(e?.error?.message)}`
      );
    }
  }
};

// src/commands/awsid/parts/description.ts
function description2() {
  return "Provides an easy way to access a particular (or all) AWS account ID's defined in the user's credentials file (src/.aws/credentials).";
}

// src/commands/awsid/parts/options.ts
var options3 = {
  all: {
    alias: "a",
    type: Boolean,
    group: "local",
    description: "looks up the AWS account ID's for all profiles in the credentials file"
  }
};

// src/commands/awsid/parts/syntax.ts
import chalk71 from "chalk";
var syntax = `yarn do {bold awsid} < ${chalk71.italic`profile-name`} | all >`;

// src/commands/awsid/index.ts
var command3 = {
  kind: "awsid",
  handler: handler2,
  description: description2,
  options: options3
};
var awsid_default = command3;

// src/commands/cert/parts/cert.ts
import chalk74 from "chalk";
import { exit as exit9 } from "process";

// src/commands/cert/parts/crypto.ts
import chalk73 from "chalk";
import { exit as exit8 } from "process";
import { execSync as execSync3 } from "child_process";

// src/shared/network/nslookup.ts
import { execSync as execSync2 } from "child_process";
var nslookup = (dnsName) => {
  try {
    const results = execSync2(`nslookup ${dnsName}`, { encoding: "utf8" });
    const ipAddress = results.split("\n").filter((i) => i.includes("Address:")).pop()?.replace(/Address: /, "");
    return ipAddress;
  } catch {
    return;
  }
};

// src/commands/cert/parts/handleDuplicateFile.ts
import { exit as exit7 } from "process";
async function handleDuplicateFile(file) {
  const filepath = currentDirectory(file);
  if (!fileExists(filepath)) {
    return filepath;
  }
  const answer = await askListQuestion(
    `The file "${file}" exists already; choose how to handle this:`,
    {
      keep: "keep existing file and move on",
      overwrite: "overwrite existing",
      rename: "change the cert's name to something else",
      quit: "quit creation of the cert"
    }
  );
  switch (answer) {
    case "keep":
      return false;
    case "quit":
      console.log();
      exit7(0);
    case "overwrite":
      return file;
    case "rename":
      const filename = await askInputQuestion(`What filename should we use?`);
      return handleDuplicateFile(filename);
  }
}

// src/commands/cert/parts/dnsAppearsInExtFile.ts
import { readFileSync as readFileSync8 } from "fs";
import { find } from "native-dash";
import chalk72 from "chalk";
var avoidDuplicationInExtFile = async (dns, ipAddress) => {
  const data = readFileSync8("extfile.cnf", "utf8");
  const locate = find(`.*DNS:${dns},IP:(.*)`, "ip");
  const { ip, found, next } = locate(data);
  const { ip: nextIp, found: nextFound } = next ? next() : { ip: void 0, found: false };
  if (found) {
    console.error(
      `- it appears that a DNS entry of {bold {green ${dns}}} (with IP of {green ${ip}}) already exists in your "extfile.cnf" file.`
    );
    if (ipAddress.trim() === ip.trim()) {
      console.error(
        `- using ${chalk72.blue`nslookup`} we see that the IP address does match that DNS entry ${"\u{1F44D}" /* thumbsUp */}`
      );
    } else if (ipAddress.trim() === "") {
      console.error(
        `- using ${chalk72.blue`nslookup`} was of no use as {green ${dns}} didn't produce any results ${"\u{1F4A9}" /* poop */}`
      );
    } else {
      console.error(
        `- using ${chalk72.blue`nslookup`} came back with an IP address of ${ipAddress}, which in case you weren't paying attention doesn't match your file where the record is ${"\u{1F632}" /* shocked */}`
      );
    }
    if (nextFound) {
      console.error(
        `- {red crikey mate}, you've got MORE than one entry for {green ${dns}}; the second reference points to ${nextIp}`
      );
    }
    const resolution = await askListQuestion(
      `What do you want to do?`,
      {
        overwrite: `{bold overwrite} the entry for ${dns} to an IP of ${ipAddress}`,
        skip: `{bold skip} modifying the file; i'm happy with where it's at`,
        quit: `{bold quit} out of this process`
      },
      { default: "skip" }
    );
    return resolution;
  } else {
    return "no-conflict";
  }
};

// src/commands/cert/parts/crypto.ts
import { readFileSync as readFileSync9, writeFileSync as writeFileSync6 } from "fs";
function validateOpenSsl() {
  const hasOpenSsl = hasShellCommandInPath("openssl");
  if (!hasOpenSsl) {
    console.error(`- ${"\u{1F4A9}" /* poop */} OpenSSL is not installed so stopping!`);
    exit8(1);
  }
}
function validateSshKeygen() {
  const hasOpenSsl = hasShellCommandInPath("ssh-keygen");
  if (!hasOpenSsl) {
    console.error(`- ${"\u{1F4A9}" /* poop */} ssh-keygen is not installed so stopping!`);
    exit8(1);
  }
}
async function ssh(o) {
  const filename = await handleDuplicateFile(`id_${o.ssh_algo}`);
  const keyLength = o.keyLength && o.keyLength > 0 ? `-b ${o.keyLength}` : "";
  const emailTail = o.email ? ` -C ${o.email}` : "";
  const command24 = `ssh-keygen -t ${o.ssh_algo} ${keyLength}${emailTail} ${filename}`;
  console.error(`- generating ${chalk73.bold.blue`SSH key`}: ${chalk73.green(command24)}`);
}
async function rsa(o) {
  const pemFile = await handleDuplicateFile(`${o.name}-key.pem`);
  if (!pemFile) {
    console.error(`- keep existing file [${chalk73.dim("")} ${o.name}-key.pem}]`);
    return;
  }
  if (pemFile === "quit") {
    console.error(`- exiting RSA and certification process`);
    exit8(0);
  }
  const command24 = `openssl genrsa ${o.ssl_algo ? `-${o.ssl_algo}` : ""} -out ${pemFile} ${o.keyLength}`;
  console.error(`- generating ${chalk73.bold.blue`RSA CA Cert`}:
  ${chalk73.green(command24)}`);
  try {
    execSync3(command24, { encoding: "utf8" });
    console.error(`- RSA key created [${pemFile}] ${"\u{1F680}" /* rocket */}
`);
  } catch {
    console.error(`- ${"\u{1F4A9}" /* poop */} problems generating the RSA key!`);
    exit8(1);
  }
}
async function appendAlternativeNames(o) {
  const filename = "extfile.cnf";
  let dns = o.name?.includes(`.${o.local_domain}`) ? o.name : `${o.name}.${o.local_domain}`;
  let ip = nslookup(dns);
  dns = await askInputQuestion("What is the DNS entry for this server?", { default: dns });
  ip = await askInputQuestion("What is the DNS entry for this server?", { default: `${ip}` });
  const resolution = await avoidDuplicationInExtFile(dns, ip || "");
  switch (resolution) {
    case "quit": {
      console.log("bye.\n");
      exit8(0);
    }
    case "skip": {
      console.error(`- ok, skipping update to file [${chalk73.dim(`extfile.cnf`)}]`);
      break;
    }
    case "overwrite": {
      console.error("- updating {green extfile.cnf} with the new info");
      const data = readFileSync9(filename, "utf8").split("\n").filter((i) => !i.includes(dns)).join("\n");
      writeFileSync6(filename, data, "utf8");
      break;
    }
    case "no-conflict": {
      const command24 = `echo "subjectAltName=DNS:${dns},IP:${ip}" >> extfile.cnf`;
      console.error(`- appending subject alternative name
  {green ${command24}}`);
      try {
        execSync3(command24, { encoding: "utf8", stdio: "inherit" });
        console.error(`
- appended [${chalk73.dim("")} extfile.cnf}] ${"\u{1F680}" /* rocket */}`);
      } catch {
        console.error("- ${emoji.poop} problems appending to the 'extfile.cnf' file!");
        exit8(1);
      }
      break;
    }
  }
}
async function fullchain_cert(o) {
  const command24 = `openssl x509 -req -sha256 -days ${o.days} -in ${o.name}.csr -CA ca.pem -CAkey ca-key.pem -out ${o.name}.pem -extfile extfile.cnf -CAcreateserial`;
  try {
    console.error(`- generating ${chalk73.bold.blue`SSL Certificate`} for ${o.name}`);
    execSync3(command24, { encoding: "utf8", stdio: "inherit" });
    console.error(`- SSL certificate created [${o.name}.pem] ${"\u{1F680}" /* rocket */}`);
  } catch (error) {
    console.error(`- ${"\u{1F4A9}" /* poop */} ran into problems: ${error?.message}`);
    exit8(1);
  }
  try {
    console.error(
      `- merging the created cert [${chalk73.dim(`${o.name}.pem`)} }] with CA certificate [${chalk73.dim(`ca.pem`)} }]
  into a fullchain cert [${chalk73.dim(`${o.name}.fullchain.pem`)} ]`
    );
    const command25 = `cat ${o.name}.pem > ${o.name}.fullchain.pem && cat ca.pem >> ${o.name}.fullchain.pem`;
    console.error(`  {bold {green ${command24}}}
`);
    execSync3(command25, { encoding: "utf8", stdio: "inherit" });
    console.error(
      `- Full Chain certificate created [${chalk73.dim(`${o.name}.fullchain.pem`)}] ${"\u{1F680}" /* rocket */}`
    );
  } catch (error) {
    console.error(`- ${"\u{1F4A9}" /* poop */} ran into problems: ${error?.message}`);
    exit8(1);
  }
}
async function pem_to_der(pemFile, _o) {
  const derFile = `${pemFile.replace(".pem", "")}.der`;
  const command24 = `openssl x509 -outform der -in ${pemFile} -out ${derFile}`;
  try {
    console.error(`- generating {bold {DER}} file from PEM:
  {green ${command24}}`);
    execSync3(command24, { encoding: "utf8", stdio: "inherit" });
    console.error(`- DER created [${derFile}] ${"\u{1F680}" /* rocket */}`);
  } catch (error) {
    console.error(
      `- ${"\u{1F4A9}" /* poop */} problems generating the DER file! ${error.message}`
    );
    exit8(1);
  }
}
async function ca_csr(o) {
  const command24 = `openssl req -new -x509 -${o.csr_algo} -days ${o.days} -key ${o.name}-key.pem -out ${o.name}.pem`;
  try {
    console.error(
      `- generating ${chalk73.bold.blue`Certificate Signing Request (CCR)`}:
  ${chalk73.green(command24)}`
    );
    execSync3(command24, { encoding: "utf8", stdio: "inherit" });
    console.error(`- CSR created [${o.name}] ${"\u{1F680}" /* rocket */}`);
  } catch {
    console.error(
      `- ${"\u{1F4A9}" /* poop */} problems generating the CCR (certificate signing request)!`
    );
    exit8(1);
  }
}
async function cert_csr(o) {
  const caKey = fileExists("ca-key.pem") ? "ca-key.pem" : await askInputQuestion(
    "Typically you'd call this command in a directory which has your CA Certificate named 'ca-key.pem' but this file doesn't exist. Please let us know where to find this file"
  );
  const csrFile = `${o.name}.csr`;
  const resolve = await handleDuplicateFile(csrFile);
  if (!resolve) {
    console.error(`- skipping CSR file creation [${chalk73.dim("")} ${resolve}}]`);
    return;
  }
  const command24 = `openssl req -new -${o.csr_algo} -subj "/CN=${o.name}" -key ${caKey} -out ${csrFile}`;
  const ipAddress = nslookup(`${o.name}.local`);
  console.log("ipAddress:", ipAddress);
  try {
    console.error(
      `- generating ${chalk73.bold.blue`Certificate Signing Request (CCR)`}:
  ${chalk73.green(command24)}`
    );
    execSync3(command24, { encoding: "utf8", stdio: "inherit" });
    console.error(`- CSR created [${o.name}] ${"\u{1F680}" /* rocket */}`);
  } catch (error) {
    console.error(
      `- ${"\u{1F4A9}" /* poop */} problems generating the CCR (certificate signing request)!

${error}`
    );
    exit8(1);
  }
}
async function createCA(o) {
  validateOpenSsl();
  await rsa(o);
  await ca_csr(o);
}
async function createCertificate(o) {
  validateOpenSsl();
  o.name = o.name || await askInputQuestion("what is the name of the server?");
  o.ssl_algo = void 0;
  await rsa(o);
  await cert_csr(o);
  await appendAlternativeNames(o);
  await fullchain_cert(o);
  const pemFile = `${o.name}.pem`;
  await pem_to_der(pemFile, o);
}
async function createSSH(o) {
  validateSshKeygen();
  await ssh(o);
}
async function certInfo(_o) {
  console.error(`- sorry but this has not been implemented yet`);
  exit8(0);
}

// src/commands/cert/parts/cert.ts
var handler3 = async ({ opts, subCommand }) => {
  if (!subCommand) {
    console.log(
      `{red - no {bold cert} sub-command found;} valid options are:
    - {green ca} or {green ssl} for SSL certs
    - {green ssh} to create an SSH key pair, and
    - {green info} for information on a particular certificate

- type ${chalk74.blue`dd cert --help`} for more info`
    );
    exit9(1);
  }
  const o = {
    days: 3650,
    csr_algo: "sha256",
    ssl_algo: "aes256",
    ssh_algo: opts.github ? "ed25519" : "rsa",
    ...opts,
    local_domain: opts.local_domain ? opts.local_domain?.replace(/^\.(.*)/, "$1") : "local"
  };
  o.name = subCommand === "ca" ? o.name || "ca" : o.name || void 0;
  o.keyLength = subCommand === "ssh" ? o.keyLength || o.ssh_algo === "rsa" ? 4096 : o.ssh_algo === "dsa" ? 512 : void 0 : o.keyLength || 4096;
  const dimQuote = chalk74.dim('"');
  switch (subCommand.toLowerCase()) {
    case "ca": {
      console.error(`- creating a ${chalk74.italic`local`} {green CA Certificate} pairing`);
      await createCA(o);
      break;
    }
    case "cert":
    case "certificate":
    case "ssl": {
      console.error(`- creating a local {green SSL Certificate} pairing`);
      await createCertificate(o);
      break;
    }
    case "ssh": {
      await createSSH(o);
      break;
    }
    case "info": {
      await certInfo(o);
      break;
    }
    default: {
      console.error(`{red - unknown sub command ${dimQuote}${chalk74.bold(subCommand)}${dimQuote} }`);
      exit9(1);
    }
  }
  exit9(0);
};

// src/commands/cert/parts/options.ts
var options4 = {
  name: {
    alias: "n",
    type: String,
    group: "local",
    description: "optionally specify the name of the certificate"
  },
  ssh: {
    type: Boolean,
    group: "local",
    description: "create an SSH certificate locally"
  },
  ssl: {
    type: Boolean,
    group: "local",
    description: "create an SSL certificate locally"
  },
  days: {
    type: Number,
    group: "local",
    description: "the number of days a certificate will valid for (default 3650)"
  },
  ssl_algo: {
    alias: "s",
    typeLabel: "<algo name>",
    type: String,
    group: "local",
    description: "the signing algo to use with SSL (default is 'aes256')"
  },
  ssh_algo: {
    type: String,
    group: "local",
    description: "the algo used; typically RSA but github now uses ed25519"
  },
  github: {
    type: Boolean,
    group: "local",
    description: "express the desire to create an SSH cert but not with RSA but ed25519"
  },
  keyLength: {
    type: Number,
    alias: "l",
    typeLabel: "<length>",
    group: "local",
    description: "cert key length; RSA defaults to 4096"
  },
  email: {
    type: String,
    alias: "e",
    typeLabel: "<you@somewhere.net>",
    group: "local",
    description: "the email you want to add to the end of the SSH cert"
  },
  local_domain: {
    type: String,
    alias: "d",
    typeLabel: "<local|home|etc>",
    group: "local",
    description: "the local DNS domain to use as a default (uses 'local' by default)"
  }
};

// src/commands/cert/parts/description.ts
function description3() {
  return "Creates a local SSL or SSH certificate via the CLI";
}

// src/commands/cert/index.ts
var subCommands = [
  { name: "ssh", summary: "create a new SSH certificate" },
  { name: "ssl", summary: "create a new SSL certificate" },
  { name: "ca", summary: "create a Cert Authority locally" },
  { name: "info", summary: "info on a cert" }
];
var command4 = {
  kind: "cert",
  handler: handler3,
  description: description3,
  options: options4,
  subCommands
};
var cert_default = command4;

// src/commands/deploy/parts/deploy.ts
import chalk76 from "chalk";

// src/shared/core/proxyToPackageManager.ts
import chalk75 from "chalk";
import { spawnSync as spawnSync4 } from "child_process";
var NON_PROXY = /* @__PURE__ */ new Set(["install", "outdated", "update", "why", "ls"]);
function isDevFlag(flag, mngr) {
  const matched = ["--save-dev", "--dev"].includes(flag);
  if (!matched) {
    return;
  }
  switch (mngr) {
    case "npm":
    case "pnpm": {
      return "--save-dev";
    }
    case "yarn": {
      return "--dev";
    }
    case "cargo": {
      return "";
    }
    default: {
      throw new Error(`unknown package manager: ${mngr}`);
    }
  }
}
function isPeerFlag(flag, mngr) {
  const matched = ["--save-peer", "--peer"].includes(flag);
  if (!matched) {
    return;
  }
  switch (mngr) {
    case "npm":
    case "pnpm": {
      return "--save-peer";
    }
    case "yarn": {
      return "--peer";
    }
    default: {
      throw new Error(`unknown package manager: ${mngr}`);
    }
  }
}
function isOptionalFlag(flag, mngr) {
  const matched = ["--save-optional", "--optional"].includes(flag);
  if (!matched) {
    return;
  }
  switch (mngr) {
    case "npm":
    case "pnpm": {
      return "--save-optional";
    }
    case "yarn": {
      return "--optional";
    }
    default: {
      throw new Error(`unknown package manager: ${mngr}`);
    }
  }
}
async function proxyToPackageManager(cmd, observations, argv) {
  if (!observations.has("packageJson")) {
    console.error(
      `- ${"\u{1F632}" /* shocked */} the ${chalk75.green(cmd)} command is only meant to used in the root of NodeJS which has a ${chalk75.blue`package.json`} file in it.
`
    );
    process.exit();
  }
  const pkgManager = await determinePackageManager({ interactive: true }, observations);
  if (pkgManager) {
    let pkgCmd;
    let isScriptCmd = false;
    const args = argv?.map(
      (a) => isPeerFlag(a, pkgManager) || isOptionalFlag(a, pkgManager) || isDevFlag(a, pkgManager) || a
    );
    switch (cmd) {
      case "link":
      case "unlink": {
        pkgCmd = `${pkgManager} ${cmd} ${args?.join(" ")}`;
        break;
      }
      case "install": {
        pkgCmd = pkgManager === "yarn" ? args && args.length > 0 ? `yarn add ${args.join(" ")}` : "yarn" : pkgManager === "pnpm" && (!args || args?.length === 0) ? `${pkgManager} install${args ? " " + args.join(" ") : ""}` : `${pkgManager} add${" " + args?.join(" ")}`;
        break;
      }
      case "outdated":
      case "upgrade":
      case "why": {
        pkgCmd = `${pkgManager} ${cmd}${argv ? " " + argv.join(" ") : ""}`;
        break;
      }
      case "ls": {
        pkgCmd = pkgManager === "yarn" ? `yarn list --pattern "${argv?.pop()}"` : `${pkgManager} ls ${argv?.pop()}`;
        break;
      }
      default: {
        isScriptCmd = true;
        pkgCmd = `${pkgManager === "yarn" ? `yarn ${cmd}${argv ? " " + argv.join(" ") : ""}` : `${pkgManager} run ${cmd}${argv ? " " + argv.join(" ") : ""}`}`;
      }
    }
    if (NON_PROXY.has(cmd)) {
      console.error(
        `- we detected use of ${chalk75.blue(pkgManager)} in this repo and will ${chalk75.italic`proxy`} "${cmd}" to: ${chalk75.blue(pkgCmd)}
`
      );
    } else {
      if (isScriptCmd && !hasScript(cmd)) {
        console.log(
          `- we ${chalk75.italic`would`} proxy this as ${chalk75.blue(pkgCmd)} but you don't have "${cmd}" defined in your scripts section.
`
        );
        process.exit();
      }
      console.error(`- we will proxy ${chalk75.blue(pkgCmd)} for you
`);
    }
    const cmdParts = pkgCmd.split(/\s+/g).filter(Boolean);
    const thread = spawnSync4(cmdParts[0], [...cmdParts.slice(1)], {
      env: { ...process.env, FORCE_COLOR: "true", TERM: "xterm-256color" },
      timeout: 0,
      stdio: "inherit"
    });
    if (thread.error) {
      throw new Error(`- ${"\u{1F4A9}" /* poop */} ran into problems running ${cmdParts.join(" ")}`);
    }
  } else {
    console.log(`- we can not currently tell ${chalk75.italic`which`} package manager you're using.`);
    const answer = await askListQuestion(
      "Would you like save the package manager to this repo in a config file?",
      ["not now, thanks", "npm", "pnpm", "yarn"]
    );
    if (answer !== "not now, thanks") {
      saveProjectConfig({ general: { pkgManager: answer } });
    }
  }
}

// src/commands/deploy/parts/deploy.ts
var description4 = "Deployment services for {bold Serverless}";
var syntax2 = `dd deploy [fn1] [fn2] <options>

${chalk76.dim`Note: ${chalk76.italic`stating particular functions is optional and if excluded will result in a full deployment of all functions.`}`}`;
var options5 = {
  interactive: {
    alias: "i",
    type: Boolean,
    group: "local",
    description: "allow interactive choices for the functions you want to deploy"
  },
  target: {
    alias: "t",
    typeLabel: "<target>",
    type: String,
    group: "local",
    description: "manually override the project target (serverless, npm)"
  },
  stage: {
    alias: "s",
    typeLabel: "<stage>",
    type: String,
    group: "local",
    description: "manually override the stage you're deploying to"
  },
  region: {
    alias: "r",
    typeLabel: "<region>",
    type: String,
    group: "local",
    description: "explicitly state the region you're deploying to"
  }
};
var handler4 = async ({ observations }) => {
  if (observations.has("serverlessFramework")) {
  } else {
    await proxyToPackageManager("deploy", observations);
  }
};

// src/commands/deploy/index.ts
var command5 = {
  kind: "deploy",
  handler: handler4,
  description: description4,
  options: options5
};
var deploy_default = command5;

// src/commands/endpoints/parts/description.ts
var description5 = "Lists out all the endpoints defined in a given AWS profile/account.";

// src/commands/endpoints/parts/endpoints.ts
import { table as table2 } from "table";
import chalk77 from "chalk";
var handler5 = async ({ opts }) => {
  const profileName = opts.profile ?? await determineProfile(opts);
  if (!profileName) {
    console.log(
      `- couldn't determine the AWS profile to use; try setting it manually with ${chalk77.inverse(
        " --profile "
      )} option or switch to interactive mode with ${chalk77.inverse(" --interactive ")}
`
    );
    process.exit(1);
  }
  const region = opts.region ?? await determineRegion(opts);
  try {
    console.log(
      `- getting API ${chalk77.italic`endpoints`} for the profile {bold  ${profileName}} [ ${region} ]`
    );
    if (region) {
      const response = await getApiGatewayEndpoints(profileName, region);
      console.log({ response });
      const restApi = response.restApi?.items ? response.restApi.items.map((i) => {
        return [i.id, i.name || "", i.description || ""];
      }) : [];
      const httpApi = response.httpApi?.Items ? response.httpApi.Items.map((i) => {
        return [
          i.ApiId || "",
          i.Name || "",
          i.ApiEndpoint || "",
          i.CorsConfiguration?.AllowMethods?.join(", ") || "None",
          i.CorsConfiguration?.AllowOrigins?.join(", ") || "unknown"
        ];
      }) : [];
      if (restApi.length > 0) {
        console.log("\nREST API Endpoints");
        console.log(table2([["id", "name", "description"], ...restApi]));
        console.log();
      } else {
        console.log(chalk77.gray` - no REST API endpoints found`);
        console.log();
      }
      if (httpApi.length > 0) {
        console.log("HTTP API Endpoints");
        const t = [["id", "name", "endpoint", "methods", "origins"], ...httpApi];
        console.log(table2(t));
      }
    } else {
      console.log(
        `- could not determine ${chalk77.bold.yellow("AWS region")}; try using ${chalk77.inverse(
          " --region "
        )} option to set it explicitly
`
      );
    }
  } catch {
  }
};

// src/commands/endpoints/parts/options.ts
var options6 = {
  profile: {
    type: String,
    typeLabel: "<profileName>",
    group: "local",
    description: "set the AWS profile explicitly"
  },
  region: {
    type: String,
    typeLabel: "<region>",
    group: "local",
    description: "set the AWS region explicitly"
  },
  interactive: {
    type: Boolean,
    group: "local",
    description: "if the AWS profile or region can't be determined, the CLI will interactively ask which to use"
  }
};

// src/commands/endpoints/index.ts
var command6 = {
  kind: "endpoints",
  handler: handler5,
  description: description5,
  options: options6
};
var endpoints_default = command6;

// src/commands/fns/parts/fns.ts
import chalk79 from "chalk";
import { omit as omit4 } from "native-dash";
import { table as table3 } from "table";

// src/commands/fns/parts/tables.ts
import chalk78 from "chalk";
function functionsApiTable(fns) {
  return toTable(
    fns,
    {
      col: "FunctionName",
      name: "Function",
      formula: (f) => [
        chalk78.dim`${String(f).split("-").slice(0, -1).join("-")}`,
        "- ",
        chalk78.bold(String(f).split("-").slice(-1))
      ].join(""),
      format: { width: 45, alignment: "left" }
    },
    {
      col: "MemorySize",
      name: "Memory",
      format: { width: 8, alignment: "center" },
      minWidth: 104
    },
    {
      col: "CodeSize",
      name: "Code Size",
      formula: (cs) => `${Math.floor(Number(cs) / 1e4) * 10} ${chalk78.italic`kb`}`,
      format: { width: 12, alignment: "right" },
      minWidth: 130
    },
    {
      col: "Timeout",
      formula: (t) => `${t}s`,
      format: { width: 8, alignment: "right" },
      minWidth: 123
    },
    {
      col: "Layers",
      formula: (i) => Array.isArray(i) ? i.map((i2) => i2?.Arn.split(":").slice(-2).join(":") || "").join("\n") : "",
      format: { width: 20, alignment: "center" },
      minWidth: 155
    },
    {
      col: "Description",
      format: { width: 42, alignment: "left", wrapWord: true }
    }
  );
}

// src/commands/fns/parts/fns.ts
import { exit as exit10 } from "process";
var handler6 = async ({
  unknown: argv,
  opts,
  observations
}) => {
  const filterBy = argv.length > 0 ? (fn) => fn.includes(argv[0]) : () => true;
  const isServerlessProject = observations.has("serverlessFramework");
  const region = opts.region ?? await determineRegion(opts);
  const stageFilterMsg = opts.stage ? `, filtered down to only those in the {bold ${opts.stage.toUpperCase()}} stage.` : "";
  if (!isServerlessProject) {
    if (opts.profile) {
      const filter3 = opts.stage ? (f) => f.FunctionName?.includes(`-${opts.stage}-`) : () => true;
      const fns = (await getAwsLambdaFunctions(opts)).Functions?.filter(filter3);
      if (fns) {
        console.log(
          `- AWS functions found using ${chalk79.bold.blue`${opts.profile}`} profile ${chalk79.dim`[ ${region} ]`}${stageFilterMsg}
`
        );
        if (opts.json) {
          console.log(
            chalk79.gray` - using ${chalk79.inverse(opts.json)} output directly from AWS api instead of a table}`
          );
          console.log(fns);
        } else {
          console.log(functionsApiTable(fns));
        }
        if (opts.output) {
          write2(opts.output, fns, { allowOverwrite: true });
        }
      }
      console.log(
        chalk79.gray` - the AWS CLI provides access to data like this with} {bold aws lambda list-functions --profile ${opts.profile}}`
      );
    } else {
      console.log("- this project does not appear to be a Serverless project!");
      console.log(
        chalk79.gray` - if you want a list of functions, you can still get this by stating an AWS profile with the "--profile" option}\n`
      );
    }
    exit10();
  } else if (observations.has("serverlessTs")) {
    if (opts.forceBuild) {
      console.log(
        `- detected use of the ${chalk79.blue(
          "typescript-microservice"
        )} template; rebuilding functions from config.`
      );
      await buildLambdaTypescriptProject();
    } else {
      console.log(
        `- detected use of the ${chalk79.blue`typescript-microservice`} template; use ${chalk79.bold.blue`--forceBuild`} to rebuild prior to listing functions.
`
      );
    }
  }
  try {
    const { width } = consoleDimensions();
    const fns = (await getServerlessYaml()).functions;
    const tableData = [
      [
        chalk79.bold.yellow("function"),
        chalk79.bold.yellow("events"),
        chalk79.bold.yellow("memory"),
        chalk79.bold.yellow("timeout"),
        chalk79.bold.yellow("description")
      ]
    ];
    if (fns) {
      for (const key of Object.keys(fns).filter(filterBy)) {
        const events = fns[key].events || [];
        tableData.push([
          key,
          events.map((i) => Object.keys(i)).join(", "),
          String(fns[key].memorySize || chalk79.grey("1024")),
          String(fns[key].timeout || chalk79.grey("3")),
          fns[key].description || ""
        ]);
      }
    }
    let tableConfig = {
      columns: {
        0: { width: 30, alignment: "left" },
        1: { width: 16, alignment: "left" },
        2: { width: 7, alignment: "center" },
        3: { width: 10, alignment: "center" },
        4: { width: 46, alignment: "left" }
      }
    };
    let output = table3(tableData, tableConfig);
    if (width < 70) {
      tableConfig = { columns: omit4(tableConfig.columns, "2", "3", "4") };
      output = table3(tableData.map((i) => i.slice(0, 2)));
    } else if (width < 80) {
      delete tableConfig.columns["3"];
      delete tableConfig.columns["4"];
      output = table3(tableData.map((i) => i.slice(0, 3)));
    } else if (width < 125) {
      delete tableConfig.columns["4"];
      output = table3(tableData.map((i) => i.slice(0, 4)));
    }
    console.log(output);
  } catch (error) {
    console.log(`- Error finding functions: ${error.message}
`);
    exit10(1);
  }
};

// src/commands/fns/parts/description.ts
function description6() {
  return "Lists all serverless function handlers and basic meta about them";
}

// src/commands/fns/parts/options.ts
import chalk80 from "chalk";
var options7 = {
  forceBuild: {
    alias: "f",
    type: Boolean,
    group: "local",
    description: `by default functions will be derived from ${chalk80.italic`serverless.yml`} but if you are in a ${chalk80.italic`typescript-microservice`} project you can force a rebuild prior to listing the functions`
  },
  profile: {
    type: String,
    group: "local",
    description: "allows you to explicitly state the AWS profile to use for this command"
  },
  region: {
    type: String,
    group: "local",
    description: "allows you to explicitly state the AWS region to use for this command"
  },
  stage: {
    type: String,
    group: "local",
    description: "allows the results to be filtered down to only those functions associated with a given stage"
  },
  json: {
    type: Boolean,
    group: "local",
    description: "display results as JSON instead of tables"
  },
  output: {
    type: String,
    typeLabel: "<filename>",
    group: "local",
    description: "output the AWS API as a JSON file in the local filesystem"
  }
};

// src/commands/fns/index.ts
var command7 = {
  kind: "fns",
  handler: handler6,
  description: description6,
  options: options7
};
var fns_default = command7;

// src/commands/image/parts/handler.ts
import { asyncExec as asyncExec6 } from "async-shelljs";
import chalk81 from "chalk";
var handler7 = async ({
  subCommand,
  opts,
  observations
}) => {
  const config = getProjectConfig().image;
  const log = logger(opts);
  const api = useImageApi(config ? config.rules : [], { clearCache: opts.force });
  switch (subCommand?.trim()) {
    case "config":
    case "configure": {
      if (config) {
        await askImageConfiguration(observations, api);
      } else {
        await askConfigureImageOptimization(observations);
      }
      break;
    }
    case "optimize":
    case "convert": {
      if (config && config.rules) {
        await api.convert();
      } else {
        throw new DevopsError(
          `Attempt to call optimize before any rules were configured!`,
          "image/not-ready"
        );
      }
      break;
    }
    case "watch": {
      if (config && config.rules) {
        const api2 = useImageApi(config.rules);
        await api2.watch();
      } else {
        throw new DevopsError(
          `Attempt to call watch before any rules were configured!`,
          "image/not-ready"
        );
      }
      break;
    }
    case "summarize":
    case "summary": {
      await api.summarize();
      break;
    }
    case "": {
      if (config) {
        log.info(
          `- the valid sub-commands for ${chalk81.blue`dd image`} are: ${chalk81.italic`config, optimize,`} and ${chalk81.italic`watch`}`
        );
      }
      break;
    }
    default: {
      log.shout(
        subCommand ? `the subcommand '${subCommand}' is not known!` : `the ${chalk81.bold.yellow`image`} command expects a ${chalk81.italic`sub-command`}`
      );
      await asyncExec6(`dd image --help`);
    }
  }
  await api.close();
};

// src/commands/image/parts/options.ts
var options8 = {
  force: {
    alias: "f",
    type: Boolean,
    group: "local",
    description: `Force a full rebuild of the image cache as well as converted images`
  }
};

// src/commands/image/index.ts
var command8 = {
  kind: "image",
  handler: handler7,
  description: "Provides an image optimization solution leveraging image resizing, blurring, and more.",
  greedy: false,
  options: options8,
  subCommands: [
    { name: "optimize", summary: "optimize/convert images based on configured rules" },
    {
      name: "watch",
      summary: "watch file system for changes to source images and optimize when changed"
    },
    { name: "config", summary: "configure rules for optimizing the images in this repo" },
    { name: "summarize", summary: "summarize the current configuration" }
  ]
};
var image_default = command8;

// src/commands/info/index.ts
import chalk86 from "chalk";

// src/commands/info/parts/otherPackages.ts
import chalk82 from "chalk";
import { isNpmInfoRepository } from "common-types";
import { formatDistanceToNow } from "date-fns";
async function getNpmInfo(pkgs, _opts) {
  const successful = [];
  const failed = [];
  const waitFor = [];
  for (const pkg of pkgs) {
    waitFor.push(
      getExternalPackageJson(pkg).then((value) => successful.push({ name: pkg, value })).catch(
        (error) => failed.push({ name: pkg, error: error instanceof Error ? error.message : String(error) })
      )
    );
  }
  await Promise.all(waitFor);
  return { successful, failed };
}
function allVersions(repo) {
  return repo["versions"];
}
function getPriorVersion(repo) {
  const idx = allVersions(repo)?.findIndex((i) => i === getLatest(repo));
  return idx > 1 ? allVersions(repo)[idx - 1] : void 0;
}
function getTagTiming(repo, tag) {
  const timestamp2 = repo.time[tag];
  if (!timestamp2) {
    return "unknown";
  }
  return `${formatDistanceToNow(new Date(timestamp2))} ago`;
}
function getLatest(repo) {
  return repo["dist-tags"]?.latest || repo.version;
}
function getUrls(npm) {
  const homepage = npm.homepage;
  const repo = isNpmInfoRepository(npm.repository) ? npm?.repository?.url || `{red no repo found!}` : npm.repository || `{red no repo found!}`;
  return {
    homepage,
    repo: convertGitUrlToHttp(repo)
  };
}
function getExports(repo) {
  const repoExports = [];
  if (repo.main) {
    repoExports.push("cjs");
  }
  if (repo.module) {
    repoExports.push("es");
  }
  if (repo.typings || repo.types) {
    repoExports.push("types");
  }
  return repoExports.length > 0 ? chalk82.italic(repoExports.join(", ")) : chalk82.italic.dim("none");
}
var COL_WIDTH = 3;
var colPaddingRequirement = (cols) => 2 * COL_WIDTH + (cols - 1) * COL_WIDTH;
async function otherPackages(pkgs, opts, _observations) {
  const info2 = await getNpmInfo(pkgs, opts);
  const data = [];
  for (const repo of info2.successful) {
    const timing = (v) => v ? { version: v, timing: getTagTiming(repo.value, v) } : void 0;
    const latest = timing(getLatest(repo.value));
    const prior = timing(getPriorVersion(repo.value));
    const urls = getUrls(repo.value);
    const author = repo.value.author ? typeof repo.value.author === "string" ? repo.value.author : `${repo.value.author.name}${repo.value.author.email ? `<${repo.value.author.email}>` : ""}` : void 0;
    const license = repo.value.license ? repo.value.license.slice(0, 8) : chalk82.red.italic`missing`;
    const urlDescription = `{bold Repo:} ${urls.repo}${urls.homepage ? `
{bold Homepage:} ${urls.homepage}` : ""}${author ? `
{bold Author:} ${author}` : ""}`;
    data.push({
      repo: repo.name,
      latest: opts.verbose ? `${latest?.version} - ${chalk82.italic(latest?.timing.replace("about ", ""))}${prior ? chalk82.dim`\n ${prior?.version} - ${chalk82.italic(prior?.timing.replace("about ", ""))}` : ""}` : getLatest(repo.value),
      license,
      exports: getExports(repo.value),
      description: repo.value.description ? [repo.value.description, urlDescription].join("\n\n") : urlDescription
    });
  }
  const { width: available } = consoleDimensions();
  const colWidth = (col) => {
    const colData = data.map((i) => i[col]);
    const adjustedWidth = (content) => content ? Math.max(...colData.map((i) => i?.length)) : 0;
    return colData.length === 0 ? 0 : Math.max(...colData.map(adjustedWidth));
  };
  const repoWidth = Math.max(colWidth("repo"), 5);
  const latestWidth = opts.verbose ? 24 : 8;
  const exportsWidth = Math.min(opts.verbose ? 8 : 14, colWidth("exports"));
  const licenseWidth = 5;
  const descWidth = available - (repoWidth + latestWidth + exportsWidth + licenseWidth + colPaddingRequirement(5));
  const cols = [
    { name: "Repo", col: "repo", format: { width: repoWidth } },
    {
      name: "Latest",
      col: "latest",
      format: { width: latestWidth, alignment: opts.verbose ? "left" : "center" }
    },
    { name: "Lic", col: "license", format: { width: licenseWidth, alignment: "center" } },
    { name: "Exports", col: "exports", format: { width: exportsWidth, wrapWord: true } },
    { name: "Description", col: "description", format: { wrapWord: true, width: descWidth } }
  ];
  console.log(toTable(data, ...cols));
}

// src/commands/info/parts/thisRepo.ts
import { asyncExec as asyncExec8 } from "async-shelljs";
import chalk85 from "chalk";
import path34 from "path";
import { format as format3, parseISO } from "date-fns";
import { table as table4 } from "table";

// src/commands/info/parts/components/monorepo.ts
import chalk84 from "chalk";

// src/shared/monorepo/getLernaPackages.ts
import { asyncExec as asyncExec7 } from "async-shelljs";
import chalk83 from "chalk";
import parse11 from "destr";
import { join as join15 } from "path";
function stripExtraneous(input) {
  const re = /.*(\[.*]).*/s;
  const [_, interior] = [...input.match(re) || []];
  return interior;
}
async function getLernaPackages(dir) {
  dir = dir ?? currentDirectory();
  const lerna = join15(dir, "node_modules/.bin/lerna");
  if (!fileExists(lerna)) {
    throw new DevopsError(
      `Attempt to get {bold green Lerna} package list failed as the Lerna command was not found locally at: ${chalk83.blue(lerna)}`,
      "not-ready/lerna-missing"
    );
  }
  const pkgs = parse11(
    stripExtraneous(await asyncExec7(`node_modules/.bin/lerna list --json`, { silent: true }))
  );
  return pkgs || [];
}

// src/commands/info/parts/components/monorepo.ts
async function monorepoInfo(o) {
  if (o.has("monorepo")) {
    const type = o.has("pnpmWorkspaces") ? `${chalk84.bold.yellow`pnpm`} workspaces` : o.has("yarnWorkspaces") ? `${chalk84.bold.yellow`yarn`} workspaces` : o.has("lerna") ? `${chalk84.bold.yellow`lerna`} workspaces` : o.has("rushjs") ? `${chalk84.bold.yellow`Rust`}` : chalk84.bold.red`unknown`;
    const list = o.has("lerna") ? `. Packages are:

${(await getLernaPackages()).map((p) => `- ${p.name}`).join("\n")}` : "";
    return ["Monorepo", `This repo is a ${chalk84.bold.green`monorepo`} managed by ${type}${list}`];
  }
  return ["", ""];
}

// src/commands/info/parts/thisRepo.ts
async function thisRepo(opts, observations) {
  let npm;
  try {
    npm = await getExternalPackageJson();
  } catch {
  }
  const pkg = getPackageJson();
  const linkedRepos = symlinks(currentDirectory("node_modules")).filter(
    (s) => !s.linkTo.startsWith(".pnpm/")
  );
  const pkgManagerConflict = observations.has("packageManagerConflict") ? `- ${chalk85.yellow.bold`${"\u2622\uFE0F" /* hazard */}`} there are conflicts in lock files from more than one package manager!` : false;
  if (pkgManagerConflict) {
    console.log(pkgManagerConflict);
    const cont = await askConfirmQuestion("Resolve this conflict?");
    if (cont) {
      await resolvePackageManagerConflict(observations);
    }
  }
  observations = getObservations();
  const linked = linkedRepos.length > 0 ? [
    "Linked\nRepos",
    linkedRepos.map((r) => `${chalk85.bold`${r.file} -`} ${chalk85.dim`${path34.posix.resolve(r.linkTo)}`}`).join("\n")
  ] : void 0;
  const pkgExports = [
    { name: "commonjs", value: pkg.main },
    { name: "esm", value: pkg.module },
    { name: "typings", value: pkg.typings || pkg.types }
  ].filter((i) => i.value);
  const exportsRow = pkgExports.length > 0 ? ["Exports", pkgExports.map((i) => `${chalk85.bold(i.name)} - ${chalk85.dim(i.value)}`).join("\n")] : ["Exports", chalk85.italic`no exports found in ${chalk85.blue`package.json`}`];
  const priorVersions = npm ? npm.versions.filter((i) => i !== npm?.version).slice(0, 5).join(", ") : "";
  const dateFormat = "dd MMM yyyy";
  const gitLastCommit = await getGitLastCommit();
  const gitRemotes = (await getGitRemotes()).map((i) => `- ${chalk85.bold(i.name)}: ${chalk85.dim(i.refs.fetch)}`);
  let gitInfo = gitLastCommit ? `- Latest commit ${green(gitLastCommit.hash.slice(0, 8))} on ${green(gitLastCommit.refs)}
- committed by ${green(gitLastCommit.author_name)} ${chalk85.dim(`<${gitLastCommit.author_email}>`)} on ${green(format3(new Date(gitLastCommit.date), dateFormat))}` : chalk85.italic.dim`no commits found`;
  const localFilesChanged = (await asyncExec8("git diff --name-only", {
    silent: true
  })).split("\n").length;
  const currentGitBranch = await getCurrentGitBranch();
  gitInfo = gitInfo + `
- ${chalk85.yellow(String(localFilesChanged))} files changed locally on ${chalk85.yellow(currentGitBranch)}

- Remotes are:
  ${gitRemotes}`;
  const npmInfo = [
    [
      true,
      npm ? `This repo was first published on ${green(format3(parseISO(npm.time.created), dateFormat))} and last modified on ${green(format3(parseISO(npm.time.modified), dateFormat))}.

` : ""
    ],
    [
      false,
      npm ? `The latest published version is ${chalk85.bold.green(npm.version)} [ ${format3(
        parseISO(npm.time[npm.version]),
        dateFormat
      )} ].
Locally in package.json, version is ${chalk85.bold.green(pkg.version)}.` : `Locally in ${chalk85.italic`package.json`}, the version is ${chalk85.bold.green(
        pkg.version
      )} but this is ${chalk85.italic`not`} an npm package.`
    ],
    [true, `

Prior versions include: ${chalk85.italic.dim(priorVersions)}`],
    [
      true,
      npm && npm.author ? `

The author of the repo is ${chalk85.green.bold(
        typeof npm.author === "string" ? npm.author : npm.author.name
      )}${typeof npm.author === "object" && npm.author.email ? ` <${npm.author.email}>` : ""}` : ""
    ]
  ];
  const deps = [
    {
      name: "dependencies",
      prop: "dependencies",
      count: Object.keys(pkg?.dependencies || {}).length
    },
    {
      name: `${chalk85.italic`dev`} dependencies`,
      prop: "devDependencies",
      count: Object.keys(pkg?.devDependencies || {}).length
    },
    {
      name: `${chalk85.italic`optional`} dependencies`,
      prop: "optionalDependencies",
      count: Object.keys(pkg?.optionalDependencies || {}).length
    },
    {
      name: `${chalk85.italic`peer`} dependencies`,
      prop: "peerDependencies",
      count: Object.keys(pkg?.peerDependencies || {}).length
    }
  ].filter((d) => d.count > 0);
  const depsSummary = deps.length > 0 ? `This repo has ${deps.map((d) => chalk85.green` ${d.count}} ${d.name}`).join(", ")}` : chalk85.italic.dim` no dependencies}}`;
  `This repo has ${green(
    Object.keys(pkg?.dependencies || {}).length
  )} dependencies, and {green ${Object.keys(pkg?.devDependencies || {}).length}} ${chalk85.italic`dev`} dependencies`;
  const depDetails = `${depsSummary}

The dependencies are:
 - ${chalk85.dim(
    Object.keys(pkg?.dependencies || {}).join("\n - ")
  )}`;
  console.log(`Info on package ${chalk85.bold.green(pkg.name)}
`);
  const npmInformation = pkg.private === true ? `This is a private repository (not published to NPM)` : npmInfo.filter((i) => opts.verbose || !i[0]).map((i) => i[1]).join("");
  const repoInfo = pkg.repository && typeof pkg.repository === "object" ? convertGitUrlToHttp(pkg.repository.url) : pkg.repository ? convertGitUrlToHttp(pkg.repository) : chalk85.red`The repository is ${chalk85.bold(
    "not"
  )} stated in ${chalk85.blue`package.json`}; it may be deduced by the GIT remotes:\n${gitRemotes.join(
    "\n"
  )}`;
  const data = [
    await monorepoInfo(observations),
    [
      chalk85.bold("Desc"),
      pkg.description ?? chalk85.bold.italic`no description provided!`
    ],
    exportsRow,
    ["NPM", npmInformation],
    [chalk85.bold("Deps"), opts.verbose === true ? depDetails : depsSummary],
    ["Repo ", repoInfo],
    [
      "Scripts",
      Object.keys(pkg?.scripts || {}).map((i) => i.includes(":") ? chalk85.dim`${i.split(":")[0]}}:${i.split(":")[1]}` : i).join(", ")
    ],
    [
      "GIT",
      gitInfo
    ],
    ["Tags ", pkg.keywords ? pkg.keywords.join(", ") : chalk85.italic.dim("none")]
  ].filter((i) => Array.isArray(i) && i[0]);
  if (linked) {
    data.push(linked);
  }
  const tblConfig = {
    columns: [{ alignment: "left" }, { width: 69, wrapWord: true }]
  };
  console.log(table4(data, tblConfig));
}

// src/commands/info/index.ts
var command9 = {
  kind: "info",
  handler: async ({ argv, opts, observations }) => {
    if (opts.listDeps) {
      console.log(pkgDepsInTable());
      return;
    }
    if (opts.allDeps) {
      const pkg = getPackageJson();
      const deps = Object.keys(pkg.dependencies || {});
      if (deps.length === 0) {
        console.log(`- there are no dependencies for this repo
`);
        process.exit();
      }
      console.log(
        `- ${"\u{1F3C3}" /* run */} getting NPM info for ${chalk86.bold.yellow(String(deps.length))} dependencies`
      );
      return otherPackages(deps, opts, observations);
    }
    return argv?.length > 0 ? otherPackages(argv, opts, observations) : thisRepo(opts, observations);
  },
  description: "Summarized information about the current repo; or alternatively a set of external npm packages (if stated).",
  options: {
    argv: {
      type: String,
      description: `${chalk86.italic`optionally`} pass in npm packages to get info on them`,
      group: "local",
      defaultOption: true,
      multiple: true
    },
    allDeps: {
      type: Boolean,
      alias: "a",
      group: "local",
      description: "If specified, will provide info across all of this repo's dependencies"
    },
    listDeps: {
      type: Boolean,
      alias: "l",
      group: "local",
      description: "List in tabular format all deps: deps, dev deps, optional and peer"
    }
  }
};
var info_default = command9;

// src/commands/install/index.ts
var command10 = {
  kind: "install",
  handler: async ({ observations, raw }) => {
    await proxyToPackageManager("install", observations, raw);
    process.exit();
  },
  description: `proxies your package manager's {bold italic install} command (and yarn's "add" command)`
};
var install_default = command10;

// src/commands/invoke/parts/invoke-meta.ts
var description7 = "invoke serverless functions locally, leveraging test data where desired";
var options9 = {
  stage: {
    type: String,
    typeLabel: "<stage>",
    group: "local",
    description: 'state the "stage" you want to emulate with invokation'
  },
  data: {
    type: String,
    typeLabel: "<dataFile>",
    group: "local",
    description: "use a known data input"
  },
  interactive: {
    alias: "i",
    type: Boolean,
    group: "local",
    description: "bring up an interactive dialog to choose the data file"
  }
};

// src/commands/invoke/parts/invoke.ts
import chalk87 from "chalk";
import { asyncExec as asyncExec9 } from "async-shelljs";
var handler8 = async ({
  observations,
  opts,
  unknown: argv,
  raw
}) => {
  if (!observations.has("serverlessFramework")) {
    await proxyToPackageManager("invoke", observations, raw);
    process.exit();
  }
  try {
    const sls = await isServerless();
    if (!sls) {
      console.log(
        `{red - This project is not configured as a {bold Serverless} project!} ${"\u{1F621}" /* angry */}
`
      );
      process.exit();
    }
    if (argv.length > 1) {
      console.log(chalk87.dim`- you have stated more than one function to ${chalk87.italic`invoke`}.`);
      console.log(chalk87.dim`- this command only executes one at a time; the rest are ignored.`);
    }
    let fn;
    if (argv.length === 0) {
      fn = await askForFunction();
    } else {
      fn = argv[0];
      const availableFns = Object.keys(
        await getLocalServerlessFunctionsFromServerlessYaml() || {}
      );
      if (!availableFns.includes(fn)) {
        console.log(
          `{red - The function "{white ${fn}}" is not a valid function!} ${"\u{1F632}" /* shocked */}`
        );
        console.log("- valid functions are:");
        console.log(chalk87.dim`  - ${availableFns.join("\n  - ")}`);
        process.exit();
      }
    }
    let data;
    if (opts.data) {
      try {
        data = await readDataFile(opts.data, "json");
      } catch {
        const possible = await getDataFiles({
          filterBy: opts.data
        });
        if (possible.length > 1) {
          data = await askForDataFile(possible);
        } else if (possible.length === 1) {
          data = await readDataFile(possible[0]);
        } else {
          console.log(`{red - Data file "${opts.data}" not found!}`);
          data = await askForDataFile();
        }
      }
    }
    if (opts.interactive) {
      data = await askForDataFile();
    }
    if (!opts.quiet) {
      console.log(
        chalk87.gray` > sls invoke local --function ${chalk87.dim`white ${fn}`} --data '${chalk87.dim.white(data)}'`
      );
    }
    await asyncExec9(`sls invoke local --function ${fn} --data '${data}'`);
  } catch (error) {
    console.log(`- Error finding functions: ${error.message}
`);
    process.exit();
  }
};

// src/commands/invoke/index.ts
var command11 = {
  kind: "invoke",
  handler: handler8,
  description: description7,
  options: options9
};
var invoke_default = command11;

// src/commands/latest/parts/description.ts
var description8 = () => "Provides the latest semver tag in the current repo.";

// src/commands/latest/parts/latest.ts
import chalk88 from "chalk";
var handler9 = async ({ opts }) => {
  const g = git();
  const { latest } = await g.tags();
  const status = await g.status();
  const pkg = getPackageJson();
  if (!pkg) {
    console.log(
      `- the "latest" command provides you with the latest version of the repo in the ${chalk88.italic`current`} directory`
    );
    console.log(
      `   however it appears you're in directory without a package.json file! ${"\u{1F632}" /* shocked */}
`
    );
    console.log(
      `- please move to a new directory or pass in the optional '--repo [repo]' parameter to name a repo`
    );
    process.exit();
  }
  const pkgVersion = pkg.version;
  const aheadBehind = status.ahead === 0 && status.behind === 0 ? "" : `
- Your local repo is ${status.ahead > 0 ? `ahead by ${status.ahead} commits` : `behind by ${status.behind} commits`}`;
  const changes = status.not_added.length === 0 && status.modified.length === 0 ? "" : `
- Locally you have ${chalk88.yellow(status.not_added.length > 0 ? status.not_added.length : "zero")} ${chalk88.italic`new`} files and ${chalk88.yellow(status.modified.length)} ${chalk88.italic`modified`} files`;
  const conflicts = status.conflicted.length === 0 ? "" : `- ${"\u{1F4A9}" /* poop */} There are ${chalk88.bold.red(status.conflicted.length)} conflicted files!`;
  if (opts.verbose) {
    console.log(
      `The remote repo's latest version is ${chalk88.bold.yellow(latest)}; ${chalk88.blue`package.json`} is ${pkgVersion === latest ? "the same" : `is ${chalk88.bold(pkgVersion)}`}.${aheadBehind}${changes}${conflicts}`
    );
    console.log("\n");
  } else {
    console.log(latest);
  }
  return latest;
};

// src/commands/latest/parts/options.ts
var options10 = {
  repo: {
    alias: "r",
    type: String,
    group: "local",
    description: `by default the "latest" command works off the current working dirs repo but you can specify a foreign npm repo and get the latest of that repo`
  }
};

// src/commands/latest/index.ts
var command12 = {
  kind: "latest",
  handler: handler9,
  description: description8,
  options: options10
};
var latest_default = command12;

// src/commands/layers/parts/description.ts
var description9 = "Reports on the AWS layers defined in a given Serverless repo";

// src/commands/layers/parts/layers.ts
import chalk89 from "chalk";
var META_LINK_MSG = chalk89.dim`- the results rely on meta-data tagging; check out this link for more info:\n      ${chalk89.blueBright`https://github.com/inocan-group/do-devops/docs/layer-meta.md`}\n`;
var handler10 = async ({ observations }) => {
  if (observations.has("serverlessFramework")) {
    const layers = getLayersFromPackageJson();
    if (layers.length > 0) {
      console.log(
        toTable(
          layers,
          { col: "name", format: { width: 30, alignment: "left" } },
          {
            col: "versions",
            formula: (v) => Array.isArray(v) ? v.pop()?.version || "unknown" : v || "unknown",
            format: { width: 7, alignment: "center" }
          },
          { col: "description", format: { width: 64, alignment: "left", wrapWord: true } }
        )
      );
      console.log(META_LINK_MSG);
    } else {
      console.log(`- there were ${chalk89.italic`no`} layers found as dependencies to this repo`);
      console.log(META_LINK_MSG);
    }
  } else {
    console.log(`- the current directory is not a Serverless repo
`);
  }
};

// src/commands/layers/index.ts
var command13 = {
  kind: "layers",
  handler: handler10,
  description: description9
};
var layers_default = command13;

// src/commands/ls/index.ts
import chalk90 from "chalk";
var command14 = {
  kind: "ls",
  handler: async ({ observations, raw, argv }) => {
    if (!observations.has("packageJson")) {
      console.log(
        `- the ${chalk90.italic`ls`} command is only useful in a directory with a ${chalk90.blue`package.json`}`
      );
      process.exit();
    }
    if (argv.length === 0) {
      console.log(
        `- in order to run the ${chalk90.italic`ls`} command, we will need you to choose a dependency of this repo
`
      );
      const dep = await askForDependency(observations);
      if (!dep) {
        process.exit();
      }
      raw = [dep];
    }
    await proxyToPackageManager("ls", observations, raw);
    return;
  },
  greedy: true,
  description: `proxies your package manager's ${chalk90.italic`ls`} / ${chalk90.italic`list`} command to determine which versions of a dep you have`
};
var ls_default = command14;

// src/commands/madge/madge.ts
import { exec as exec2 } from "async-shelljs";
import chalk92 from "chalk";
import { exit as exit11 } from "process";

// src/commands/madge/parts/options.ts
import chalk91 from "chalk";
var options11 = {
  circular: {
    type: Boolean,
    alias: "c",
    group: "local",
    description: `Madge's ${chalk91.bold.italic`circular`} circular reference checker`
  },
  orphans: {
    type: Boolean,
    alias: "o",
    group: "local",
    description: `Madge's ${chalk91.bold.italic`orphans`} checker which shows which modules no one is depending on`
  },
  leaves: {
    type: Boolean,
    alias: "l",
    group: "local",
    description: `Madge's ${chalk91.bold.italic`leaves`} checker which shows modules with no dependencies`
  },
  summary: {
    type: Boolean,
    alias: "s",
    group: "local",
    description: `Madge's ${chalk91.bold.italic`summary`} command which provides an overview to repo`
  },
  json: {
    type: Boolean,
    alias: "j",
    group: "local",
    description: "output as JSON"
  },
  image: {
    type: String,
    alias: "i",
    group: "local",
    description: "write graph to file as an image"
  },
  layout: {
    type: String,
    group: "local",
    description: `layout engine for graph; choices are: ${chalk91.dim.italic` dot, neato, fdp, sfdp, twopi, circo`}`
  },
  "include-npm": {
    type: Boolean,
    group: "local",
    description: "include shallow NPM modules (default: false)"
  },
  extensions: {
    type: String,
    group: "local",
    description: `comma separated string of valid file extensions (uses ${chalk91.bold.italic`js,ts`} as a default)`
  }
};

// src/commands/madge/madge.ts
var command15 = {
  kind: "madge",
  handler: async ({ opts, argv }) => {
    const log = logger(opts);
    const flags = [];
    if (opts.verbose) {
      flags.push("--debug", "--warning");
    }
    if (opts.json) {
      flags.push("--json");
    }
    if (opts.extensions) {
      flags.push(`--extensions ${opts.extensions}`);
    } else {
      flags.push(`--extensions ts,js`);
    }
    if (opts.layout) {
      const valid = ["dot", "neato", "fdp", "sfdp", "twopi", "circo"];
      if (!valid.includes(opts.layout)) {
        log.info(
          `- ${"\u26A0\uFE0F" /* warn */} you passed in ${chalk92.red`${opts.layout}`} for a ${chalk92.italic`layout`}; this will likely not be recognized by ${chalk92.blue`madge`} CLI`
        );
        log.info(chalk92.gray`{ - valid layouts include: ${chalk92.italic(valid.join(", "))}`);
      }
      flags.push(`--layout ${opts.layout}`);
    }
    if (opts["include-npm"]) {
      flags.push("--include-npm");
    }
    if (opts.image) {
      flags.push(`--image ${opts.image}`);
    }
    const dir = argv[0] || "src";
    if (!opts.circular && !opts.summary && !opts.orphans && !opts.leaves) {
      const which = await askListQuestion(
        `Which ${chalk92.italic`Madge`} command(s) would you like to run?`,
        ["circular", "summary", "orphans", "leaves"]
      );
      opts[which] = true;
    }
    if (opts.circular) {
      const cmd = `pnpx madge ${dir} --circular ${flags.join(" ")}`;
      log.info(`
- running ${chalk92.bold`madge`} with following command: ${chalk92.blue(cmd)}`);
      const response = exec2(cmd);
      if (response.code !== 0) {
        exit11(response.code);
      }
    }
    if (opts.summary) {
      const cmd = `npx madge ${dir} --summary ${flags.join(" ")}`;
      log.info(`
- running ${chalk92.bold`madge`} with following command: ${chalk92.blue(cmd)}`);
      const response = exec2(cmd);
      if (response.code !== 0) {
        exit11(response.code);
      }
    }
    if (opts.orphans) {
      const cmd = `npx madge ${dir} --orphans ${flags.join(" ")}`;
      log.info(`
- running ${chalk92.bold`madge`} with following command: ${chalk92.blue(cmd)}`);
      const response = exec2(cmd);
      if (response.code !== 0) {
        exit11(response.code);
      }
    }
    if (opts.leaves) {
      const cmd = `npx madge --leaves ${flags.join(" ")}`;
      log.info(`
- running ${chalk92.bold`madge`} with following command: ${chalk92.blue(cmd)}`);
      const response = exec2(cmd);
      if (response.code !== 0) {
        exit11(response.code);
      }
    }
    return;
  },
  description: `provides a proxy of the highly useful ${chalk92.bold`madge`} utilities; by default running across all javascript and typescript files in the ${chalk92.blue`src`} directory.`,
  options: options11
};
var madge_default = command15;

// src/commands/madge/index.ts
var madge_default2 = madge_default;

// src/commands/outdated/index.ts
var command16 = {
  kind: "outdated",
  handler: async ({ observations, raw }) => {
    await proxyToPackageManager("outdated", observations, raw);
    process.exit();
  },
  description: "proxies your package manager's 'outdated' command"
};
var outdated_default = command16;

// src/commands/pkg/parts/pkg.ts
import chalk93 from "chalk";
import { asyncExec as asyncExec10 } from "async-shelljs";
var handler11 = async ({ opts, observations }) => {
  const stage = await determineStage(opts);
  const region = await determineRegion(opts);
  if (!observations.has("serverlessFramework")) {
    console.log(
      `  - the {bold pkg} command is only intended for use in repos that use the Serverless framework
`
    );
    return;
  }
  console.log(
    `- ${chalk93.bold`Serverless`} ${chalk93.italic`packaging`} for {bold ${stage}} stage ${"\u{1F389}" /* party */}`
  );
  const command24 = `sls package --stage ${stage} --region ${region} ${opts.dir ? `--package ${opts.dir}` : ""}`;
  console.log(chalk93.dim.italic`${command24}\n`);
  await asyncExec10(command24, { silent: opts.quiet ? true : false });
  const directory = opts.dir ?? ".serverless";
  console.log(`
{bold {green - Packaging is complete!}} ${"\u{1F680}" /* rocket */}`);
  console.log(`- the assets can all be found in the ${chalk93.italic.blue`${directory}} directory.}`}`);
  await asyncExec10(`ls -l ${directory}`);
  if (opts.validate) {
    console.log(
      `
- validating the ${chalk93.bold`cloudformation`} ${chalk93.italic`create`} template ${"\u{1F440}" /* eyeballs */}`
    );
    const validateCmd = `aws cloudformation validate-template --template-body file://${directory}/cloudformation-template-create-stack.json`;
    try {
      console.log(chalk93.dim`   ${validateCmd}`);
      await asyncExec10(validateCmd);
    } catch {
      console.log(`{red - Error validating the ${chalk93.italic`create`} template!}`);
    }
    console.log(
      `
- validating the {bold cloudformation} ${chalk93.italic`update`} template ${"\u{1F440}" /* eyeballs */}`
    );
    const validateUpdate = `aws cloudformation validate-template --template-body file://${directory}/cloudformation-template-update-stack.json`;
    try {
      console.log(chalk93.dim`   ${validateUpdate}`);
      await asyncExec10(validateUpdate);
    } catch {
      console.log(chalk93.red`- Error validating the ${chalk93.italic` update`} template! ${"\u{1F4A9}" /* poop */}`);
    }
  }
};

// src/commands/pkg/parts/pkg-meta.ts
import chalk94 from "chalk";
var description10 = `Package up resources for {bold Serverless} publishing but do not actually ${chalk94.italic`deploy`}.`;
var options12 = {
  stage: {
    type: String,
    typeLabel: "<stage>",
    group: "local",
    description: "the AWS stage which is being targeted"
  },
  profile: {
    type: String,
    typeLabel: "<profile>",
    group: "local",
    description: "The AWS credential profile being used for this CLI command"
  },
  region: {
    type: String,
    typeLabel: "<region>",
    group: "local",
    description: "The AWS region being used for this CLI command"
  },
  dir: {
    alias: "d",
    type: String,
    typeLabel: "<directory>",
    group: "local",
    description: `by default assets are saved to the ${chalk94.italic`.serverless`} directory but you can change this to a different directory if you like.`
  },
  validate: {
    type: Boolean,
    group: "local",
    description: `after the package is completed the {bold cloudformation} template can be validated`
  }
};

// src/commands/pkg/index.ts
var command17 = {
  kind: "pkg",
  handler: handler11,
  description: description10,
  options: options12
};
var pkg_default = command17;

// src/commands/scaffold/parts/meta.ts
var description11 = "helps to scaffold a project with common features";
var options13 = {};

// src/commands/scaffold/parts/scaffold.ts
import chalk95 from "chalk";
import { asyncExec as asyncExec11 } from "async-shelljs";
import { exit as exit12 } from "process";
var scaffolds = [
  "gitignore",
  "git",
  "typescript",
  "eslint",
  "jest",
  "vitesse",
  "vitesse-webext"
];
var handler12 = async ({
  opts,
  observations
}) => {
  opts = { ...opts, silent: true };
  const which = await askCheckboxQuestion("choose the scaffolds you want to use", scaffolds);
  if (which.includes("gitignore")) {
    await installGitIgnore(opts);
  }
  if (which.includes("git")) {
    await installGit(opts);
  }
  if (which.includes("typescript")) {
    await installTypescript(opts, observations);
  }
  if (which.includes("eslint")) {
    await installEsLint(opts, observations);
  }
  if (which.includes("jest")) {
    await installTestFramework("jest", opts, observations);
  }
  if (which.includes("vitesse") || which.includes("vitesse-webext")) {
    const pkg = which.includes("vitesse-webext") ? "vitesse-webext" : "vitesse";
    let confirm = true;
    let dir = ".";
    if (observations.has("packageJson")) {
      confirm = await askConfirmQuestion(
        `- install ${chalk95.bold.blue`Vitesse${pkg.includes("ext") ? chalk95.italic` browser extension` : ""}`} starter template for VueJS/ViteJS into ${chalk95.bold.yellow`current`} directory?`
      );
    } else {
      const dirChoices = [
        "current directory",
        ...getSubdirectories(process.cwd()),
        "(new subdirectory)"
      ];
      const subOrCurrent = await askListQuestion(
        wordWrap(
          `- since you're not in a dir with a ${chalk95.italic`package.json`} we need to establish which directory you want to install the {bold blue Vitesse} start template into.`
        ),
        dirChoices
      );
      if (subOrCurrent === "(new subdirectory)") {
        dir = await askInputQuestion("- specify directory name:");
      } else if (subOrCurrent === "current directory") {
        dir = ".";
      } else {
        dir = subOrCurrent;
      }
    }
    if (confirm) {
      asyncExec11(`npx degit antfu/${pkg} ${dir} --force`);
      console.log(
        `- vitesse ${pkg.includes("ext") ? "browser extension " : ""}template installed`
      );
      await asyncExec11(`pnpm install`);
      console.log(
        `
- ${"\u{1F389}" /* party */} Vitesse ${pkg.includes("ext") ? "browser extension " : ""}template installed and all deps are loaded 
`
      );
    } else {
      exit12(0);
    }
  }
  return;
};

// src/commands/scaffold/index.ts
var command18 = {
  kind: "scaffold",
  handler: handler12,
  description: description11,
  options: options13
};
var scaffold_default = command18;

// src/commands/ssm/parts/description.ts
import chalk96 from "chalk";
function description12(..._opts) {
  return `allows an easy interaction with AWS's ${chalk96.bold.yellow`SSM`} parameter system for managing secrets. Subcommands include: ${chalk96.italic`set`}, ${chalk96.italic`get`}, and ${chalk96.italic`list`}.`;
}

// src/commands/ssm/parts/options.ts
import chalk97 from "chalk";
var options14 = {
  profile: {
    type: String,
    typeLabel: "<profileName>",
    group: "local",
    description: "set the AWS profile explicitly"
  },
  region: {
    type: String,
    typeLabel: "<region>",
    group: "local",
    description: "set the AWS region explicitly"
  },
  stage: {
    type: String,
    typeLabel: "<stage>",
    group: "local",
    description: "set the stage explicitly"
  },
  nonStandardPath: {
    type: Boolean,
    group: "local",
    description: "allows the naming convention for SSM paths to be ignored for a given operation"
  },
  description: {
    type: String,
    group: "local",
    description: "sets the description of the SSM variable (only used in ADD)"
  },
  force: {
    alias: "f",
    type: Boolean,
    group: "local",
    description: `force a ${chalk97.italic`set`} operation to complete even when the variable being set already exists`
  },
  base64: {
    type: Boolean,
    group: "local",
    description: `adding this flag will encode with base64 when adding and decode from base64 to utf-8 when getting`
  }
};

// src/commands/ssm/parts/ssm.ts
import chalk102 from "chalk";

// src/commands/ssm/private/subCommands/index.ts
var subCommands_exports = {};
__export(subCommands_exports, {
  get: () => get_exports,
  list: () => list_exports,
  set: () => set_exports
});

// src/commands/ssm/private/subCommands/get.ts
var get_exports = {};
__export(get_exports, {
  execute: () => execute
});
import chalk98 from "chalk";
import { fromBase64 } from "native-dash";
import { SSM } from "aws-ssm";
import { format as format4 } from "date-fns";
import { table as table5 } from "table";
var execute = async ({ opts, unknown }) => {
  const profile2 = await determineProfile({ ...opts, interactive: true });
  if (!profile2) {
    console.log(
      `- Couldn't determine the AWS Profile; try setting it manually with {inverse  --profile }.`
    );
    console.log(
      `- alternatively use the {inverse --interactive } option to have the CLI interactively let you select`
    );
    process.exit();
  }
  const profileInfo = await getAwsProfile(profile2);
  const region = opts.region || profileInfo.region || await determineRegion({ ...opts, interactive: true });
  const secrets = unknown;
  const nonStandardPath = opts.nonStandardPath || false;
  const { width } = consoleDimensions();
  if (!region) {
    throw new DevopsError(
      `Getting SSM secrets requires an ${chalk98.bold(
        "AWS Region"
      )} and none could be deduced. You can explicitly state this by adding "--region XYZ" to the command.`
    );
  }
  if (!profile2) {
    throw new DevopsError(
      `Getting SSM secrets requires an ${chalk98.bold(
        "AWS Profile"
      )} and none could be deduced. You can explicitly state this by adding "--profile XYZ" to the command.`
    );
  }
  if (!opts.quiet) {
    console.log(`- Getting SSM details for: ${chalk98.italic.grey.bold(secrets.join(", "))}
`);
  }
  const tableConfig = {
    columns: {
      0: { width: 30, alignment: "left" },
      1: { width: width > 125 ? 60 : width > 100 ? 40 : 35 },
      2: { width: 8, alignment: "center" },
      3: { width: 16, alignment: "center" }
    }
  };
  const ssm = new SSM({ profile: profile2, region });
  for await (const secret of secrets) {
    const tableData = [
      [
        chalk98.yellow.bold("Path"),
        chalk98.yellow.bold("ARN"),
        chalk98.yellow.bold("Version"),
        chalk98.yellow.bold("LastUpdated")
      ]
    ];
    const data = await ssm.get(secret, { decrypt: true, nonStandardPath });
    tableData.push([
      data.path,
      data.arn,
      String(data.version),
      format4(data.lastUpdated, "dd MMM, yyyy")
    ]);
    const value = opts.base64 ? fromBase64(String(data.value)) : String(data.value);
    if (!opts.quiet) {
      console.log(table5(tableData, tableConfig));
      console.log(chalk98.yellow.bold("VALUE:\n"));
      console.log(value);
      console.log();
    } else {
      console.log(value);
    }
  }
};

// src/commands/ssm/private/subCommands/list.ts
var list_exports = {};
__export(list_exports, {
  execute: () => execute2
});
import chalk99 from "chalk";
import process5 from "process";
import { format as format5 } from "date-fns";
import { table as table6 } from "table";
import { SSM as SSM2 } from "aws-ssm";
var execute2 = async ({
  opts,
  observations,
  unknown: argv
}) => {
  const profile2 = await determineProfile({ ...opts, interactive: true }, observations);
  if (!profile2) {
    console.log(
      `- Couldn't determine the AWS Profile; try setting it manually with {inverse  --profile }.`
    );
    console.log(
      `- alternatively use the {inverse --interactive } option to have the CLI interactively let you select`
    );
    process5.exit();
  }
  const profileInfo = await getAwsProfile(profile2);
  const region = opts.region || profileInfo.region || await determineRegion({ ...opts, interactive: true });
  const filterBy = argv.length > 0 ? argv[0] : void 0;
  if (!profile2 || !region) {
    console.log(chalk99.red`- missing information!`);
    console.log(
      `To list SSM params the AWS ${chalk99.italic`profile`} and ${chalk99.italic`region`} must be stated. These could {bold not} be determined so exiting.`
    );
    console.log(
      `${chalk99.dim(`note that the easiest way to get an explicit profile/region is to use the ${chalk99.bold("--profile")} and ${chalk99.bold("--region")} switches on the command line.}
`)}`
    );
    process5.exit();
  }
  if (!opts.quiet) {
    console.log(
      `- Listing SSM parameters in profile "${chalk99.bold(profile2)}", region "${chalk99.bold(
        region
      )}"${filterBy ? `; results reduced to those with "${chalk99.bold(filterBy)}" in the name.` : ""}`
    );
    console.log();
  }
  const ssm = new SSM2({
    profile: profile2,
    region
  });
  const list = await ssm.describeParameters();
  const tableData = [
    [
      chalk99.bold("Name"),
      chalk99.bold("Version"),
      chalk99.bold("Type"),
      chalk99.bold("LastModified"),
      chalk99.bold("User")
    ]
  ];
  for (const i of list.filter((i2) => !filterBy || (i2.Name || "").includes(filterBy))) {
    tableData.push([
      i.Name || "",
      String(i.Version),
      i.Type || "",
      i.LastModifiedDate ? format5(i.LastModifiedDate, "dd MMM, yyyy") : "",
      i.LastModifiedUser ? i.LastModifiedUser.replace(/.*user\//, "") : ""
    ]);
  }
  const tableConfig = {
    columns: {
      0: { width: 42, alignment: "left" },
      1: { width: 8, alignment: "center" },
      2: { width: 14, alignment: "center" },
      3: { width: 18, alignment: "center" },
      4: { width: 14 }
    }
  };
  console.log(table6(tableData, tableConfig));
};

// src/commands/ssm/private/subCommands/set.ts
var set_exports = {};
__export(set_exports, {
  execute: () => execute3
});
import { SSM as SSM3 } from "aws-ssm";
import { toBase64 } from "native-dash";
import chalk100 from "chalk";
var execute3 = async ({ opts, unknown: argv }) => {
  if (argv.length < 2) {
    console.log(
      `The "dd ssm set" command expects the variable name and value as parameters on the command line: ${chalk100.blue.bold`do ssm set`} <${chalk100.italic`name`}> <${chalk100.italic`value`}>
`
    );
    console.log(
      chalk100.gray`${chalk100.bold` - Note:`} you can include a ${chalk100.italic`partial name`} for the variable and things like the AWS profile, region, stage, and version number\n  will be filled in where possible\n`
    );
    process.exit(1);
  }
  let [name, value] = argv;
  const profile2 = await determineProfile({ ...opts, interactive: true });
  if (!profile2) {
    console.log(
      `- Couldn't determine the AWS Profile; try setting it manually with {inverse  --profile }.`
    );
    console.log(
      `- alternatively use the ${chalk100.inverse` --interactive `} option to have the CLI interactively let you select`
    );
    process.exit();
  }
  const profileInfo = await getAwsProfile(profile2);
  const identity = await getAwsIdentityFromProfile(profileInfo);
  const region = opts.region || profileInfo.region || await determineRegion(opts);
  const stage = opts.stage || process.env.AWS_STAGE || process.env.NODE_ENV || await askForStage(
    `SSM variables should be namespaced to a STAGE, what stage are you setting for ${chalk100.dim`[ profile: ${chalk100.italic(profile2)}, region: ${chalk100.italic(region)}, account: ${chalk100.italic(identity.accountId)} ]`}?`
  );
  const ssm = new SSM3({ profile: profile2, region });
  name = await completeSsmName(name, { stage });
  if (opts.base64) {
    value = toBase64(value);
  }
  process.env.AWS_STAGE = stage;
  try {
    await ssm.put(name, value, {
      description: opts.description,
      override: opts.force
    });
    console.log(
      `
- ${"\u{1F389}" /* party */} the {bold {yellow ${name}}} variable was set successfully to the ${chalk100.italic(region)} region ${chalk100.dim`[ profile: ${chalk100.italic(profile2)}, region: ${chalk100.italic(region)}, account: ${chalk100.italic(identity.accountId)} ]`}
`
    );
  } catch (error) {
    console.log();
    if (error?.code === "ParameterAlreadyExists") {
      console.log(
        `- {red {bold Parameter Already Exists!}} to overwrite a parameter which already exists you must add ${chalk100.blue`--force`} to the CLI command`
      );
    } else {
      console.log(`${chalk100.red.bold`Error:`} ${error.message}`);
    }
    console.log();
    process.exit(1);
  }
};

// src/commands/ssm/private/completeSsmName.ts
import chalk101 from "chalk";
function nameToUpper(parts) {
  return [...parts.slice(0, -1), parts.slice(-1)[0].toUpperCase()].join("/");
}
async function completeSsmName(name, hints = {}) {
  const parts = name.split("/");
  const lastIsUpper = parts.slice(-1)[0].toUpperCase() === parts.slice(-1)[0];
  if (!lastIsUpper) {
    console.log(
      `
- The last component of the name is intended -- ${chalk101.italic`by convention`} -- to be UPPERCASE.
  Therefore we will convert your name to ${nameToUpper(
        parts
      )} with your permission.
`
    );
    const cont = await askConfirmQuestion("Continue?");
    if (!cont) {
      console.log();
      process.exit();
    }
  }
  if (parts.length === 2) {
    return `/${hints.stage || "dev"}/${hints.version || 1}/${nameToUpper(parts)}`;
  }
  if (parts.length > 2) {
    if (Number.isInteger(parts[1])) {
      return nameToUpper(parts);
    } else {
      console.log(
        `
The SSM variable ${chalk101.italic`name`} does not appear to be correctly formatted. The format
should be:
`
      );
      console.log(`/${chalk101.dim` [stage]`}/${chalk101.dim` [version]`}/${chalk101.dim` [moduleName]`}/${chalk101.dim` [VAR NAME]`}
`);
      console.log(
        `In most cases the best strategy is just to state the module name and final
variable name and let the autocomplete do the rest.`
      );
      throw new DevopsError("Incorrect SSM variable formatting", "ssm/invalid-format");
    }
  }
  throw new DevopsError("Incorrect SSM variable structure", "ssm/invalid-structure");
}

// src/commands/ssm/parts/ssm.ts
var handler13 = async (input) => {
  const { subCommand, observations } = input;
  const validSubCommands = ["list", "get", "set"];
  if (!subCommand) {
    console.log(
      `- the SSM command requires you pick a valid sub-command; choose from: ${chalk102.italic(validSubCommands.join(", "))}`
    );
    process.exit();
  }
  if (!validSubCommands.includes(subCommand)) {
    console.log(
      `- please choose a ${chalk102.italic("valid")} ${chalk102.bold.yellow(
        "SSM"
      )} sub-command: ${Object.keys(subCommands_exports).join(", ")}`
    );
    console.log();
    process.exit();
  }
  const serverless = observations.has("serverlessFramework") && observations.has("serverlessTs");
  if (serverless) {
    await buildLambdaTypescriptProject();
  }
  try {
    await subCommands_exports[subCommand].execute(input);
  } catch (error) {
    console.log(
      `{red - Ran into error when running "ssm ${subCommand}":}
  - ${error.message}
`
    );
    console.log(chalk102.gray`- ${error.stack}`);
    process.exit(1);
  }
};

// src/commands/ssm/parts/subCommands.ts
var subCommands2 = [
  { name: "list", summary: "list all SSM secrets in a given AWS profile" },
  { name: "get", summary: "get the details for a particular SSM secret" },
  { name: "set", summary: "set/add a SSM secret" }
];

// src/commands/ssm/index.ts
var command19 = {
  kind: "ssm",
  handler: handler13,
  description: description12,
  options: options14,
  subCommands: subCommands2
};
var ssm_default = command19;

// src/commands/tree/index.ts
import chalk103 from "chalk";
import { spawnSync as spawnSync5 } from "child_process";
var command20 = {
  kind: "tree",
  handler: async ({ observations, raw, opts }) => {
    if (observations.has("cargo")) {
      const params = opts.verbose ? ["modules", "generate", "tree", "--with-types"] : ["modules", "generate", "tree"];
      console.error(
        `- proxying the "tree" command to ${chalk103.blue.bold`cargo`} ${params.join(" ")}}`
      );
      const thread = spawnSync5("cargo", params, { stdio: "inherit" });
      if (thread.error) {
        throw new Error(`- ${"\u{1F4A9}" /* poop */} ran into problems using cargo's modules plugin}`);
      }
    } else {
      if (commandIsAvailable("tree")) {
        const thread = spawnSync5("tree", raw);
        if (thread.error) {
          throw new Error(`- ${"\u{1F4A9}" /* poop */} ran into problems using cargo's modules plugin}`);
        }
      } else {
        console.log(
          `- no "tree" binary was found in the path; if you're on Mac you can install with 'brew install tree'
`
        );
      }
    }
    process.exit();
  },
  description: "if in Cargo/Rust dir then tries cargo's module tree plugin; otherwise proxies an 'in-path' tree executable "
};
var tree_default = command20;

// src/commands/upgrade/index.ts
var command21 = {
  kind: "upgrade",
  handler: async ({ observations, raw }) => {
    await proxyToPackageManager("upgrade", observations, raw);
    process.exit();
  },
  description: "proxies your package manager's 'upgrade' command"
};
var upgrade_default = command21;

// src/commands/watch/index.ts
import chalk104 from "chalk";
var command22 = {
  kind: "watch",
  handler: async ({ observations, raw }) => {
    if (!observations.has("packageJson")) {
      console.log(
        `- ${chalk104.italic`watching`} files in the repo is something which can only happen in directory with a ${chalk104.blue`package.json`}`
      );
      process.exit();
    }
    if (observations.has("serverlessFramework")) {
      if (hasScript("watch")) {
        console.log(
          chalk104.gray`y - {bold note:} this is a serverless project but because you have a "watch" script, we will prefer that over the default do-devops watcher`
        );
        proxyToPackageManager("watch", observations, raw);
        process.exit();
      } else {
        console.log(`- starting the Serverless Devops watcher`);
        process.exit();
      }
    }
    await proxyToPackageManager("watch", observations, raw);
    process.exit();
  },
  description: "proxies your package manager's 'watch' command"
};
var watch_default = command22;

// src/commands/why/index.ts
import chalk105 from "chalk";
var command23 = {
  kind: "why",
  handler: async ({ observations, raw }) => {
    if (raw.length === 0) {
      console.log(
        `- invalid command syntax, you must state a repo to report on: ${chalk105.blue`dd {bold [repo]`} ${chalk105.italic`[opts]`}
`
      );
      if (observations.has("packageJson")) {
        console.log(
          chalk105.gray` - you often want to target a repo that is listed as a dependency in this repo.\n- The deps in this repo are (${chalk105.italic`excluding dev deps`}):\n`
        );
        console.log(pkgDepsInTable({ ignoreDevDeps: true }));
      }
      process.exit();
    }
    await proxyToPackageManager("why", observations, raw);
    process.exit();
  },
  description: "proxies your package manager's 'why' command"
};
var why_default = command23;

// src/commands/index.ts
var commands_default = {
  add: add_default,
  autoindex: autoindex_default,
  awsid: awsid_default,
  cert: cert_default,
  deploy: deploy_default,
  endpoints: endpoints_default,
  fns: fns_default,
  image: image_default,
  info: info_default,
  install: install_default,
  invoke: invoke_default,
  latest: latest_default,
  layers: layers_default,
  ls: ls_default,
  madge: madge_default2,
  outdated: outdated_default,
  pkg: pkg_default,
  scaffold: scaffold_default,
  ssm: ssm_default,
  tree: tree_default,
  upgrade: upgrade_default,
  watch: watch_default,
  why: why_default
};

// src/shared/core/helpContent.ts
import { keys } from "inferred-types";

// src/shared/core/isKnownCommand.ts
function isKnownCommand(cmd) {
  return typeof cmd === "string" && getAllCommands().map((i) => i.kind).includes(cmd);
}

// src/shared/core/options.ts
import chalk107 from "chalk";
var globalOptions = {
  quiet: {
    alias: "q",
    type: Boolean,
    group: "global",
    description: `stops all output to ${chalk107.italic`stdout`}`
  },
  verbose: {
    alias: "v",
    type: Boolean,
    group: "global",
    description: "makes the output more verbose"
  },
  help: {
    alias: "h",
    type: Boolean,
    group: "global",
    description: "shows help for given command"
  }
};

// src/shared/core/parseCmdArgs.ts
import commandLineArgs from "command-line-args";
function parseCmdArgs(cmd, incomingArgv) {
  const subCommandDefn = {
    command: {
      type: String,
      group: "subCommand",
      defaultOption: true,
      ...cmd.greedy ? { multiple: true } : {}
    }
  };
  const greedyCommandDefn = {
    argv: {
      type: String,
      group: "argv",
      defaultOption: true,
      multiple: true
    }
  };
  const optDefn = cmd.subCommands ? { ...globalOptions, ...subCommandDefn, ...cmd.options } : { ...globalOptions, ...cmd.options, ...cmd.greedy ? greedyCommandDefn : {} };
  const { global, local, _unknown, subCommand, argv } = commandLineArgs(
    convertOptionsToArray(optDefn),
    {
      argv: incomingArgv,
      partial: true
    }
  );
  const opts = { ...global, ...local };
  const sc = subCommand ? cmd.greedy ? subCommand?.command[0] : subCommand?.command : void 0;
  return {
    subCommand: sc,
    argv: cmd.greedy ? sc ? sc?.slice(1) || [] : argv.argv || [] : [],
    raw: incomingArgv,
    opts,
    unknown: _unknown || []
  };
}

// src/shared/core/commands/getCommand.ts
function getCommand(cmd) {
  const defn = commands_default[cmd];
  if (!isDoDevopsCommand(defn)) {
    throw new DevopsError(
      `The command "${cmd}" is not defined correctly! Make sure all commands export a valid 'IDoDevopsCommand' interface.`,
      "do-devops/invalid-command-definition"
    );
  }
  return commands_default[cmd];
}

// src/shared/core/commands/getAllCommands.ts
import { keys as keys2 } from "inferred-types";
function getAllCommands(observations = /* @__PURE__ */ new Set(), opts = {}) {
  return keys2(commands_default).map(
    (cmd) => finalizeCommandDefinition(getCommand(cmd), observations, opts)
  );
}

// src/dd.ts
(async () => {
  const mainCommand = commandLineArgs2([{ name: "command", defaultOption: true, type: String }], {
    stopAtFirstUnknown: true
  });
  const remaining = mainCommand._unknown || [];
  const cmdName = mainCommand.command;
  if (!cmdName && mainCommand._unknown && mainCommand._unknown.includes("--version")) {
    console.log(doDevopsVersion());
    process.exit();
  }
  const observations = getObservations();
  if (!cmdName && mainCommand._unknown && mainCommand._unknown.includes("--observations")) {
    console.log(
      chalk108.yellowBright`Observations:\n`,
      wordWrap([...observations].map((i) => chalk108.dim(i)).join(chalk108.dim(", ")))
    );
    process.exit();
  }
  if (!cmdName) {
    commandAnnouncement();
    help(observations);
    process.exit();
  }
  if (isKnownCommand(cmdName)) {
    const cmdDefn = getCommand(cmdName);
    let cmdInput = { ...parseCmdArgs(cmdDefn, remaining), observations };
    if (cmdInput.opts.help) {
      commandAnnouncement(cmdDefn, cmdInput);
      help(observations, cmdDefn);
      process.exit();
    }
    try {
      commandAnnouncement(cmdDefn, cmdInput);
      cmdInput = {
        ...cmdInput,
        argv: hasArgv(cmdDefn) ? cmdInput.opts[getArgvOption(cmdDefn)?.name] : []
      };
      await cmdDefn.handler(cmdInput);
      if (cmdInput.unknown && cmdInput.unknown?.filter((i) => i).length > 0) {
        const plural = cmdInput.unknown.length === 1 ? false : true;
        const preposition = cmdInput.unknown.length === 1 ? "was" : "were";
        console.error(
          `- Note: ${chalk108.italic`there ${preposition}`} ${cmdInput.unknown.length} ${chalk108.italic`unknown`} parameter${plural ? "s" : ""} received (and ignored): ${chalk108.gray(cmdInput.unknown.join(", "))}`
        );
      }
    } catch (error) {
      console.error(
        `
{red An Error has occurred while running: ${chalk108.italic.bold`do-devops ${cmdName}`}`
      );
      console.error(`- ${error.message}`);
      console.error(chalk108.gray`  ${error.stack}\n`);
      process.exit();
    }
  } else {
    let useScriptProxy;
    try {
      useScriptProxy = hasScript(cmdName) || ["link", "unlink"].includes(cmdName);
    } catch (error) {
      useScriptProxy = isDevopsError(error) && error.classification === "not-ready/missing-package-json" ? false : void 0;
    }
    if (useScriptProxy) {
      proxyToPackageManager(cmdName, observations, mainCommand._unknown);
    } else {
      const noPkgJsonMsg = useScriptProxy === void 0 ? "" : chalk108.dim`\n\n - Note: you're in a directory with no ${chalk108.italic`package.json`} file so if you\nwere trying to proxy a script please move to the right directory first.`;
      console.log(
        `${"\u{1F4A9}" /* poop */} ${chalk108.italic.yellowBright`${cmdName}`}} is an unknown command!${noPkgJsonMsg} 

- Valid command syntax is: ${chalk108.bold.inverse(
          " dd [command] <options> "
        )}
  where valid commands are: ${chalk108.italic(
          getAllCommands().map((i) => i.kind).sort().join(", ")
        )}

${chalk108.dim(` - If you want more help with a specific command, use`)} ${inverted(
          " dd [cmd] --help "
        )}
`
      );
    }
  }
})();
